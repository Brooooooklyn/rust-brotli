extern {
    fn BrotliAllocate(
        m : *mut MemoryManager, n : usize
    ) -> *mut ::std::os::raw::c_void;
    fn BrotliConvertBitDepthsToSymbols(
        depth : *const u8, len : usize, bits : *mut u16
    );
    fn BrotliCreateHuffmanTree(
        data : *const u32,
        length : usize,
        tree_limit : i32,
        tree : *mut HuffmanTree,
        depth : *mut u8
    );
    fn BrotliFree(
        m : *mut MemoryManager, p : *mut ::std::os::raw::c_void
    );
    fn BrotliSetDepth(
        p : i32, pool : *mut HuffmanTree, depth : *mut u8, max_depth : i32
    ) -> i32;
    fn BrotliWriteHuffmanTree(
        depth : *const u8,
        num : usize,
        tree_size : *mut usize,
        tree : *mut u8,
        extra_bits_data : *mut u8
    );
    fn __swbuf(arg1 : i32, arg2 : *mut __sFILE) -> i32;
    fn memcpy(
        __dst : *mut ::std::os::raw::c_void,
        __src : *const ::std::os::raw::c_void,
        __n : usize
    ) -> *mut ::std::os::raw::c_void;
    fn memset(
        __b : *mut ::std::os::raw::c_void, __c : i32, __len : usize
    ) -> *mut ::std::os::raw::c_void;
}

enum __sFILEX {
}

static mut kLog2Table
    : [f64; 256]
    = [   0.0000000000000000f64,
          0.0000000000000000f64,
          1.0000000000000000f64,
          1.5849625007211563f64,
          2.0000000000000000f64,
          2.3219280948873622f64,
          2.5849625007211561f64,
          2.8073549220576042f64,
          3.0000000000000000f64,
          3.1699250014423126f64,
          3.3219280948873626f64,
          3.4594316186372978f64,
          3.5849625007211565f64,
          3.7004397181410922f64,
          3.8073549220576037f64,
          3.9068905956085187f64,
          4.0000000000000000f64,
          4.0874628412503400f64,
          4.1699250014423122f64,
          4.2479275134435852f64,
          4.3219280948873626f64,
          4.3923174227787607f64,
          4.4594316186372973f64,
          4.5235619560570131f64,
          4.5849625007211570f64,
          4.6438561897747244f64,
          4.7004397181410926f64,
          4.7548875021634691f64,
          4.8073549220576037f64,
          4.8579809951275728f64,
          4.9068905956085187f64,
          4.9541963103868758f64,
          5.0000000000000000f64,
          5.0443941193584534f64,
          5.0874628412503400f64,
          5.1292830169449664f64,
          5.1699250014423122f64,
          5.2094533656289501f64,
          5.2479275134435852f64,
          5.2854022188622487f64,
          5.3219280948873626f64,
          5.3575520046180838f64,
          5.3923174227787607f64,
          5.4262647547020979f64,
          5.4594316186372973f64,
          5.4918530963296748f64,
          5.5235619560570131f64,
          5.5545888516776376f64,
          5.5849625007211570f64,
          5.6147098441152083f64,
          5.6438561897747244f64,
          5.6724253419714961f64,
          5.7004397181410926f64,
          5.7279204545631996f64,
          5.7548875021634691f64,
          5.7813597135246599f64,
          5.8073549220576046f64,
          5.8328900141647422f64,
          5.8579809951275719f64,
          5.8826430493618416f64,
          5.9068905956085187f64,
          5.9307373375628867f64,
          5.9541963103868758f64,
          5.9772799234999168f64,
          6.0000000000000000f64,
          6.0223678130284544f64,
          6.0443941193584534f64,
          6.0660891904577721f64,
          6.0874628412503400f64,
          6.1085244567781700f64,
          6.1292830169449672f64,
          6.1497471195046822f64,
          6.1699250014423122f64,
          6.1898245588800176f64,
          6.2094533656289510f64,
          6.2288186904958804f64,
          6.2479275134435861f64,
          6.2667865406949019f64,
          6.2854022188622487f64,
          6.3037807481771031f64,
          6.3219280948873617f64,
          6.3398500028846252f64,
          6.3575520046180847f64,
          6.3750394313469254f64,
          6.3923174227787598f64,
          6.4093909361377026f64,
          6.4262647547020979f64,
          6.4429434958487288f64,
          6.4594316186372982f64,
          6.4757334309663976f64,
          6.4918530963296748f64,
          6.5077946401986964f64,
          6.5235619560570131f64,
          6.5391588111080319f64,
          6.5545888516776376f64,
          6.5698556083309478f64,
          6.5849625007211561f64,
          6.5999128421871278f64,
          6.6147098441152092f64,
          6.6293566200796095f64,
          6.6438561897747253f64,
          6.6582114827517955f64,
          6.6724253419714952f64,
          6.6865005271832185f64,
          6.7004397181410917f64,
          6.7142455176661224f64,
          6.7279204545631988f64,
          6.7414669864011465f64,
          6.7548875021634691f64,
          6.7681843247769260f64,
          6.7813597135246599f64,
          6.7944158663501062f64,
          6.8073549220576037f64,
          6.8201789624151887f64,
          6.8328900141647422f64,
          6.8454900509443757f64,
          6.8579809951275719f64,
          6.8703647195834048f64,
          6.8826430493618416f64,
          6.8948177633079437f64,
          6.9068905956085187f64,
          6.9188632372745955f64,
          6.9307373375628867f64,
          6.9425145053392399f64,
          6.9541963103868758f64,
          6.9657842846620879f64,
          6.9772799234999168f64,
          6.9886846867721664f64,
          7.0000000000000000f64,
          7.0112272554232540f64,
          7.0223678130284544f64,
          7.0334230015374501f64,
          7.0443941193584534f64,
          7.0552824355011898f64,
          7.0660891904577721f64,
          7.0768155970508317f64,
          7.0874628412503400f64,
          7.0980320829605272f64,
          7.1085244567781700f64,
          7.1189410727235076f64,
          7.1292830169449664f64,
          7.1395513523987937f64,
          7.1497471195046822f64,
          7.1598713367783891f64,
          7.1699250014423130f64,
          7.1799090900149345f64,
          7.1898245588800176f64,
          7.1996723448363644f64,
          7.2094533656289492f64,
          7.2191685204621621f64,
          7.2288186904958804f64,
          7.2384047393250794f64,
          7.2479275134435861f64,
          7.2573878426926521f64,
          7.2667865406949019f64,
          7.2761244052742384f64,
          7.2854022188622487f64,
          7.2946207488916270f64,
          7.3037807481771031f64,
          7.3128829552843557f64,
          7.3219280948873617f64,
          7.3309168781146177f64,
          7.3398500028846243f64,
          7.3487281542310781f64,
          7.3575520046180847f64,
          7.3663222142458151f64,
          7.3750394313469254f64,
          7.3837042924740528f64,
          7.3923174227787607f64,
          7.4008794362821844f64,
          7.4093909361377026f64,
          7.4178525148858991f64,
          7.4262647547020979f64,
          7.4346282276367255f64,
          7.4429434958487288f64,
          7.4512111118323299f64,
          7.4594316186372973f64,
          7.4676055500829976f64,
          7.4757334309663976f64,
          7.4838157772642564f64,
          7.4918530963296748f64,
          7.4998458870832057f64,
          7.5077946401986964f64,
          7.5156998382840436f64,
          7.5235619560570131f64,
          7.5313814605163119f64,
          7.5391588111080319f64,
          7.5468944598876373f64,
          7.5545888516776376f64,
          7.5622424242210728f64,
          7.5698556083309478f64,
          7.5774288280357487f64,
          7.5849625007211561f64,
          7.5924570372680806f64,
          7.5999128421871278f64,
          7.6073303137496113f64,
          7.6147098441152075f64,
          7.6220518194563764f64,
          7.6293566200796095f64,
          7.6366246205436488f64,
          7.6438561897747244f64,
          7.6510516911789290f64,
          7.6582114827517955f64,
          7.6653359171851765f64,
          7.6724253419714952f64,
          7.6794800995054464f64,
          7.6865005271832185f64,
          7.6934869574993252f64,
          7.7004397181410926f64,
          7.7073591320808825f64,
          7.7142455176661224f64,
          7.7210991887071856f64,
          7.7279204545631996f64,
          7.7347096202258392f64,
          7.7414669864011465f64,
          7.7481928495894596f64,
          7.7548875021634691f64,
          7.7615512324444795f64,
          7.7681843247769260f64,
          7.7747870596011737f64,
          7.7813597135246608f64,
          7.7879025593914317f64,
          7.7944158663501062f64,
          7.8008998999203047f64,
          7.8073549220576037f64,
          7.8137811912170374f64,
          7.8201789624151887f64,
          7.8265484872909159f64,
          7.8328900141647422f64,
          7.8392037880969445f64,
          7.8454900509443757f64,
          7.8517490414160571f64,
          7.8579809951275719f64,
          7.8641861446542798f64,
          7.8703647195834048f64,
          7.8765169465650002f64,
          7.8826430493618425f64,
          7.8887432488982601f64,
          7.8948177633079446f64,
          7.9008668079807496f64,
          7.9068905956085187f64,
          7.9128893362299619f64,
          7.9188632372745955f64,
          7.9248125036057813f64,
          7.9307373375628867f64,
          7.9366379390025719f64,
          7.9425145053392399f64,
          7.9483672315846778f64,
          7.9541963103868758f64,
          7.9600019320680806f64,
          7.9657842846620870f64,
          7.9715435539507720f64,
          7.9772799234999168f64,
          7.9829935746943104f64,
          7.9886846867721664f64,
          7.9943534368588578f64
      ];

#[no_mangle]
pub unsafe extern fn log2(mut v : f64) -> f64 {
    if v < 0i32 as (f64) {
        0i32 as (f64)
    } else if v < 256i32 as (f64) {
        kLog2Table[v as (usize)]
    } else {
        let mut count : f64 = 0i32 as (f64);
        while 1i32 != 0 {
            v = v / 2i32 as (f64);
            count = count + 1.0f64;
            if v < 256i32 as (f64) {
                return kLog2Table[v as (usize)] + count;
            }
        }
    }
}

static mut kLog2Table
    : [f32; 256]
    = [   0.0000000000000000f32,
          0.0000000000000000f32,
          1.0000000000000000f32,
          1.5849625007211563f32,
          2.0000000000000000f32,
          2.3219280948873622f32,
          2.5849625007211561f32,
          2.8073549220576042f32,
          3.0000000000000000f32,
          3.1699250014423126f32,
          3.3219280948873626f32,
          3.4594316186372978f32,
          3.5849625007211565f32,
          3.7004397181410922f32,
          3.8073549220576037f32,
          3.9068905956085187f32,
          4.0000000000000000f32,
          4.0874628412503400f32,
          4.1699250014423122f32,
          4.2479275134435852f32,
          4.3219280948873626f32,
          4.3923174227787607f32,
          4.4594316186372973f32,
          4.5235619560570131f32,
          4.5849625007211570f32,
          4.6438561897747244f32,
          4.7004397181410926f32,
          4.7548875021634691f32,
          4.8073549220576037f32,
          4.8579809951275728f32,
          4.9068905956085187f32,
          4.9541963103868758f32,
          5.0000000000000000f32,
          5.0443941193584534f32,
          5.0874628412503400f32,
          5.1292830169449664f32,
          5.1699250014423122f32,
          5.2094533656289501f32,
          5.2479275134435852f32,
          5.2854022188622487f32,
          5.3219280948873626f32,
          5.3575520046180838f32,
          5.3923174227787607f32,
          5.4262647547020979f32,
          5.4594316186372973f32,
          5.4918530963296748f32,
          5.5235619560570131f32,
          5.5545888516776376f32,
          5.5849625007211570f32,
          5.6147098441152083f32,
          5.6438561897747244f32,
          5.6724253419714961f32,
          5.7004397181410926f32,
          5.7279204545631996f32,
          5.7548875021634691f32,
          5.7813597135246599f32,
          5.8073549220576046f32,
          5.8328900141647422f32,
          5.8579809951275719f32,
          5.8826430493618416f32,
          5.9068905956085187f32,
          5.9307373375628867f32,
          5.9541963103868758f32,
          5.9772799234999168f32,
          6.0000000000000000f32,
          6.0223678130284544f32,
          6.0443941193584534f32,
          6.0660891904577721f32,
          6.0874628412503400f32,
          6.1085244567781700f32,
          6.1292830169449672f32,
          6.1497471195046822f32,
          6.1699250014423122f32,
          6.1898245588800176f32,
          6.2094533656289510f32,
          6.2288186904958804f32,
          6.2479275134435861f32,
          6.2667865406949019f32,
          6.2854022188622487f32,
          6.3037807481771031f32,
          6.3219280948873617f32,
          6.3398500028846252f32,
          6.3575520046180847f32,
          6.3750394313469254f32,
          6.3923174227787598f32,
          6.4093909361377026f32,
          6.4262647547020979f32,
          6.4429434958487288f32,
          6.4594316186372982f32,
          6.4757334309663976f32,
          6.4918530963296748f32,
          6.5077946401986964f32,
          6.5235619560570131f32,
          6.5391588111080319f32,
          6.5545888516776376f32,
          6.5698556083309478f32,
          6.5849625007211561f32,
          6.5999128421871278f32,
          6.6147098441152092f32,
          6.6293566200796095f32,
          6.6438561897747253f32,
          6.6582114827517955f32,
          6.6724253419714952f32,
          6.6865005271832185f32,
          6.7004397181410917f32,
          6.7142455176661224f32,
          6.7279204545631988f32,
          6.7414669864011465f32,
          6.7548875021634691f32,
          6.7681843247769260f32,
          6.7813597135246599f32,
          6.7944158663501062f32,
          6.8073549220576037f32,
          6.8201789624151887f32,
          6.8328900141647422f32,
          6.8454900509443757f32,
          6.8579809951275719f32,
          6.8703647195834048f32,
          6.8826430493618416f32,
          6.8948177633079437f32,
          6.9068905956085187f32,
          6.9188632372745955f32,
          6.9307373375628867f32,
          6.9425145053392399f32,
          6.9541963103868758f32,
          6.9657842846620879f32,
          6.9772799234999168f32,
          6.9886846867721664f32,
          7.0000000000000000f32,
          7.0112272554232540f32,
          7.0223678130284544f32,
          7.0334230015374501f32,
          7.0443941193584534f32,
          7.0552824355011898f32,
          7.0660891904577721f32,
          7.0768155970508317f32,
          7.0874628412503400f32,
          7.0980320829605272f32,
          7.1085244567781700f32,
          7.1189410727235076f32,
          7.1292830169449664f32,
          7.1395513523987937f32,
          7.1497471195046822f32,
          7.1598713367783891f32,
          7.1699250014423130f32,
          7.1799090900149345f32,
          7.1898245588800176f32,
          7.1996723448363644f32,
          7.2094533656289492f32,
          7.2191685204621621f32,
          7.2288186904958804f32,
          7.2384047393250794f32,
          7.2479275134435861f32,
          7.2573878426926521f32,
          7.2667865406949019f32,
          7.2761244052742384f32,
          7.2854022188622487f32,
          7.2946207488916270f32,
          7.3037807481771031f32,
          7.3128829552843557f32,
          7.3219280948873617f32,
          7.3309168781146177f32,
          7.3398500028846243f32,
          7.3487281542310781f32,
          7.3575520046180847f32,
          7.3663222142458151f32,
          7.3750394313469254f32,
          7.3837042924740528f32,
          7.3923174227787607f32,
          7.4008794362821844f32,
          7.4093909361377026f32,
          7.4178525148858991f32,
          7.4262647547020979f32,
          7.4346282276367255f32,
          7.4429434958487288f32,
          7.4512111118323299f32,
          7.4594316186372973f32,
          7.4676055500829976f32,
          7.4757334309663976f32,
          7.4838157772642564f32,
          7.4918530963296748f32,
          7.4998458870832057f32,
          7.5077946401986964f32,
          7.5156998382840436f32,
          7.5235619560570131f32,
          7.5313814605163119f32,
          7.5391588111080319f32,
          7.5468944598876373f32,
          7.5545888516776376f32,
          7.5622424242210728f32,
          7.5698556083309478f32,
          7.5774288280357487f32,
          7.5849625007211561f32,
          7.5924570372680806f32,
          7.5999128421871278f32,
          7.6073303137496113f32,
          7.6147098441152075f32,
          7.6220518194563764f32,
          7.6293566200796095f32,
          7.6366246205436488f32,
          7.6438561897747244f32,
          7.6510516911789290f32,
          7.6582114827517955f32,
          7.6653359171851765f32,
          7.6724253419714952f32,
          7.6794800995054464f32,
          7.6865005271832185f32,
          7.6934869574993252f32,
          7.7004397181410926f32,
          7.7073591320808825f32,
          7.7142455176661224f32,
          7.7210991887071856f32,
          7.7279204545631996f32,
          7.7347096202258392f32,
          7.7414669864011465f32,
          7.7481928495894596f32,
          7.7548875021634691f32,
          7.7615512324444795f32,
          7.7681843247769260f32,
          7.7747870596011737f32,
          7.7813597135246608f32,
          7.7879025593914317f32,
          7.7944158663501062f32,
          7.8008998999203047f32,
          7.8073549220576037f32,
          7.8137811912170374f32,
          7.8201789624151887f32,
          7.8265484872909159f32,
          7.8328900141647422f32,
          7.8392037880969445f32,
          7.8454900509443757f32,
          7.8517490414160571f32,
          7.8579809951275719f32,
          7.8641861446542798f32,
          7.8703647195834048f32,
          7.8765169465650002f32,
          7.8826430493618425f32,
          7.8887432488982601f32,
          7.8948177633079446f32,
          7.9008668079807496f32,
          7.9068905956085187f32,
          7.9128893362299619f32,
          7.9188632372745955f32,
          7.9248125036057813f32,
          7.9307373375628867f32,
          7.9366379390025719f32,
          7.9425145053392399f32,
          7.9483672315846778f32,
          7.9541963103868758f32,
          7.9600019320680806f32,
          7.9657842846620870f32,
          7.9715435539507720f32,
          7.9772799234999168f32,
          7.9829935746943104f32,
          7.9886846867721664f32,
          7.9943534368588578f32
      ];

static mut kInsBase
    : [u32; 24]
    = [   0i32 as (u32),
          1i32 as (u32),
          2i32 as (u32),
          3i32 as (u32),
          4i32 as (u32),
          5i32 as (u32),
          6i32 as (u32),
          8i32 as (u32),
          10i32 as (u32),
          14i32 as (u32),
          18i32 as (u32),
          26i32 as (u32),
          34i32 as (u32),
          50i32 as (u32),
          66i32 as (u32),
          98i32 as (u32),
          130i32 as (u32),
          194i32 as (u32),
          322i32 as (u32),
          578i32 as (u32),
          1090i32 as (u32),
          2114i32 as (u32),
          6210i32 as (u32),
          22594i32 as (u32)
      ];

static mut kInsExtra
    : [u32; 24]
    = [   0i32 as (u32),
          0i32 as (u32),
          0i32 as (u32),
          0i32 as (u32),
          0i32 as (u32),
          0i32 as (u32),
          1i32 as (u32),
          1i32 as (u32),
          2i32 as (u32),
          2i32 as (u32),
          3i32 as (u32),
          3i32 as (u32),
          4i32 as (u32),
          4i32 as (u32),
          5i32 as (u32),
          5i32 as (u32),
          6i32 as (u32),
          7i32 as (u32),
          8i32 as (u32),
          9i32 as (u32),
          10i32 as (u32),
          12i32 as (u32),
          14i32 as (u32),
          24i32 as (u32)
      ];

static mut kCopyBase
    : [u32; 24]
    = [   2i32 as (u32),
          3i32 as (u32),
          4i32 as (u32),
          5i32 as (u32),
          6i32 as (u32),
          7i32 as (u32),
          8i32 as (u32),
          9i32 as (u32),
          10i32 as (u32),
          12i32 as (u32),
          14i32 as (u32),
          18i32 as (u32),
          22i32 as (u32),
          30i32 as (u32),
          38i32 as (u32),
          54i32 as (u32),
          70i32 as (u32),
          102i32 as (u32),
          134i32 as (u32),
          198i32 as (u32),
          326i32 as (u32),
          582i32 as (u32),
          1094i32 as (u32),
          2118i32 as (u32)
      ];

static mut kCopyExtra
    : [u32; 24]
    = [   0i32 as (u32),
          0i32 as (u32),
          0i32 as (u32),
          0i32 as (u32),
          0i32 as (u32),
          0i32 as (u32),
          0i32 as (u32),
          0i32 as (u32),
          1i32 as (u32),
          1i32 as (u32),
          2i32 as (u32),
          2i32 as (u32),
          3i32 as (u32),
          3i32 as (u32),
          4i32 as (u32),
          4i32 as (u32),
          5i32 as (u32),
          5i32 as (u32),
          6i32 as (u32),
          7i32 as (u32),
          8i32 as (u32),
          9i32 as (u32),
          10i32 as (u32),
          24i32 as (u32)
      ];

static mut kUTF8ContextLookup
    : [u8; 512]
    = [   0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          4i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          8i32 as (u8),
          12i32 as (u8),
          16i32 as (u8),
          12i32 as (u8),
          12i32 as (u8),
          20i32 as (u8),
          12i32 as (u8),
          16i32 as (u8),
          24i32 as (u8),
          28i32 as (u8),
          12i32 as (u8),
          12i32 as (u8),
          32i32 as (u8),
          12i32 as (u8),
          36i32 as (u8),
          12i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          32i32 as (u8),
          32i32 as (u8),
          24i32 as (u8),
          40i32 as (u8),
          28i32 as (u8),
          12i32 as (u8),
          12i32 as (u8),
          48i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          48i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          48i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          48i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          48i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          24i32 as (u8),
          12i32 as (u8),
          28i32 as (u8),
          12i32 as (u8),
          12i32 as (u8),
          12i32 as (u8),
          56i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          56i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          56i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          56i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          56i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          24i32 as (u8),
          12i32 as (u8),
          28i32 as (u8),
          12i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8)
      ];

static mut kSigned3BitContextLookup
    : [u8; 256]
    = [   0i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          7i32 as (u8)
      ];

static kBrotliMinWindowBits : i32 = 10i32;

static kBrotliMaxWindowBits : i32 = 24i32;

#[derive(Clone, Copy)]
#[repr(C)]
pub struct __sbuf {
    pub _base : *mut u8,
    pub _size : i32,
}

#[derive(Clone, Copy)]
#[repr(C)]
pub struct __sFILE {
    pub _p : *mut u8,
    pub _r : i32,
    pub _w : i32,
    pub _flags : i16,
    pub _file : i16,
    pub _bf : __sbuf,
    pub _lbfsize : i32,
    pub _cookie : *mut ::std::os::raw::c_void,
    pub _close : unsafe extern fn(*mut ::std::os::raw::c_void) -> i32,
    pub _read : unsafe extern fn(*mut ::std::os::raw::c_void, *mut u8, i32) -> i32,
    pub _seek : unsafe extern fn(*mut ::std::os::raw::c_void, isize, i32) -> isize,
    pub _write : unsafe extern fn(*mut ::std::os::raw::c_void, *const u8, i32) -> i32,
    pub _ub : __sbuf,
    pub _extra : *mut __sFILEX,
    pub _ur : i32,
    pub _ubuf : [u8; 3],
    pub _nbuf : [u8; 1],
    pub _lb : __sbuf,
    pub _blksize : i32,
    pub _offset : isize,
}

#[no_mangle]
pub unsafe extern fn __sputc(
    mut _c : i32, mut _p : *mut __sFILE
) -> i32 {
    if {
           (*_p)._w = (*_p)._w - 1;
           (*_p)._w
       } >= 0i32 || (*_p)._w >= (*_p)._lbfsize && (_c as (u8) as (i32) != b'\n' as (i32)) {
        {
            let _rhs = _c;
            let _lhs
                = &mut *{
                            let _old = (*_p)._p;
                            (*_p)._p = (*_p)._p.offset(1 as (isize));
                            _old
                        };
            *_lhs = _rhs as (u8);
            *_lhs
        } as (i32)
    } else {
        __swbuf(_c,_p)
    }
}

static mut kCodeLengthDepth
    : [u8; 18]
    = [   4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          0i32 as (u8),
          4i32 as (u8),
          4i32 as (u8)
      ];

static mut kStaticCommandCodeDepth
    : [u8; 704]
    = [   9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          9i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8),
          11i32 as (u8)
      ];

static mut kStaticDistanceCodeDepth
    : [u8; 64]
    = [   6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8)
      ];

static mut kCodeLengthBits
    : [u32; 18]
    = [   0i32 as (u32),
          8i32 as (u32),
          4i32 as (u32),
          12i32 as (u32),
          2i32 as (u32),
          10i32 as (u32),
          6i32 as (u32),
          14i32 as (u32),
          1i32 as (u32),
          9i32 as (u32),
          5i32 as (u32),
          13i32 as (u32),
          3i32 as (u32),
          15i32 as (u32),
          31i32 as (u32),
          0i32 as (u32),
          11i32 as (u32),
          7i32 as (u32)
      ];

static mut kZeroRepsBits
    : [usize; 704]
    = [   0x0i32 as (usize),
          0x0i32 as (usize),
          0x0i32 as (usize),
          0x7i32 as (usize),
          0x17i32 as (usize),
          0x27i32 as (usize),
          0x37i32 as (usize),
          0x47i32 as (usize),
          0x57i32 as (usize),
          0x67i32 as (usize),
          0x77i32 as (usize),
          0x770i32 as (usize),
          0xb87i32 as (usize),
          0x1387i32 as (usize),
          0x1b87i32 as (usize),
          0x2387i32 as (usize),
          0x2b87i32 as (usize),
          0x3387i32 as (usize),
          0x3b87i32 as (usize),
          0x397i32 as (usize),
          0xb97i32 as (usize),
          0x1397i32 as (usize),
          0x1b97i32 as (usize),
          0x2397i32 as (usize),
          0x2b97i32 as (usize),
          0x3397i32 as (usize),
          0x3b97i32 as (usize),
          0x3a7i32 as (usize),
          0xba7i32 as (usize),
          0x13a7i32 as (usize),
          0x1ba7i32 as (usize),
          0x23a7i32 as (usize),
          0x2ba7i32 as (usize),
          0x33a7i32 as (usize),
          0x3ba7i32 as (usize),
          0x3b7i32 as (usize),
          0xbb7i32 as (usize),
          0x13b7i32 as (usize),
          0x1bb7i32 as (usize),
          0x23b7i32 as (usize),
          0x2bb7i32 as (usize),
          0x33b7i32 as (usize),
          0x3bb7i32 as (usize),
          0x3c7i32 as (usize),
          0xbc7i32 as (usize),
          0x13c7i32 as (usize),
          0x1bc7i32 as (usize),
          0x23c7i32 as (usize),
          0x2bc7i32 as (usize),
          0x33c7i32 as (usize),
          0x3bc7i32 as (usize),
          0x3d7i32 as (usize),
          0xbd7i32 as (usize),
          0x13d7i32 as (usize),
          0x1bd7i32 as (usize),
          0x23d7i32 as (usize),
          0x2bd7i32 as (usize),
          0x33d7i32 as (usize),
          0x3bd7i32 as (usize),
          0x3e7i32 as (usize),
          0xbe7i32 as (usize),
          0x13e7i32 as (usize),
          0x1be7i32 as (usize),
          0x23e7i32 as (usize),
          0x2be7i32 as (usize),
          0x33e7i32 as (usize),
          0x3be7i32 as (usize),
          0x3f7i32 as (usize),
          0xbf7i32 as (usize),
          0x13f7i32 as (usize),
          0x1bf7i32 as (usize),
          0x23f7i32 as (usize),
          0x2bf7i32 as (usize),
          0x33f7i32 as (usize),
          0x3bf7i32 as (usize),
          0x1c387i32 as (usize),
          0x5c387i32 as (usize),
          0x9c387i32 as (usize),
          0xdc387i32 as (usize),
          0x11c387i32 as (usize),
          0x15c387i32 as (usize),
          0x19c387i32 as (usize),
          0x1dc387i32 as (usize),
          0x1cb87i32 as (usize),
          0x5cb87i32 as (usize),
          0x9cb87i32 as (usize),
          0xdcb87i32 as (usize),
          0x11cb87i32 as (usize),
          0x15cb87i32 as (usize),
          0x19cb87i32 as (usize),
          0x1dcb87i32 as (usize),
          0x1d387i32 as (usize),
          0x5d387i32 as (usize),
          0x9d387i32 as (usize),
          0xdd387i32 as (usize),
          0x11d387i32 as (usize),
          0x15d387i32 as (usize),
          0x19d387i32 as (usize),
          0x1dd387i32 as (usize),
          0x1db87i32 as (usize),
          0x5db87i32 as (usize),
          0x9db87i32 as (usize),
          0xddb87i32 as (usize),
          0x11db87i32 as (usize),
          0x15db87i32 as (usize),
          0x19db87i32 as (usize),
          0x1ddb87i32 as (usize),
          0x1e387i32 as (usize),
          0x5e387i32 as (usize),
          0x9e387i32 as (usize),
          0xde387i32 as (usize),
          0x11e387i32 as (usize),
          0x15e387i32 as (usize),
          0x19e387i32 as (usize),
          0x1de387i32 as (usize),
          0x1eb87i32 as (usize),
          0x5eb87i32 as (usize),
          0x9eb87i32 as (usize),
          0xdeb87i32 as (usize),
          0x11eb87i32 as (usize),
          0x15eb87i32 as (usize),
          0x19eb87i32 as (usize),
          0x1deb87i32 as (usize),
          0x1f387i32 as (usize),
          0x5f387i32 as (usize),
          0x9f387i32 as (usize),
          0xdf387i32 as (usize),
          0x11f387i32 as (usize),
          0x15f387i32 as (usize),
          0x19f387i32 as (usize),
          0x1df387i32 as (usize),
          0x1fb87i32 as (usize),
          0x5fb87i32 as (usize),
          0x9fb87i32 as (usize),
          0xdfb87i32 as (usize),
          0x11fb87i32 as (usize),
          0x15fb87i32 as (usize),
          0x19fb87i32 as (usize),
          0x1dfb87i32 as (usize),
          0x1c397i32 as (usize),
          0x5c397i32 as (usize),
          0x9c397i32 as (usize),
          0xdc397i32 as (usize),
          0x11c397i32 as (usize),
          0x15c397i32 as (usize),
          0x19c397i32 as (usize),
          0x1dc397i32 as (usize),
          0x1cb97i32 as (usize),
          0x5cb97i32 as (usize),
          0x9cb97i32 as (usize),
          0xdcb97i32 as (usize),
          0x11cb97i32 as (usize),
          0x15cb97i32 as (usize),
          0x19cb97i32 as (usize),
          0x1dcb97i32 as (usize),
          0x1d397i32 as (usize),
          0x5d397i32 as (usize),
          0x9d397i32 as (usize),
          0xdd397i32 as (usize),
          0x11d397i32 as (usize),
          0x15d397i32 as (usize),
          0x19d397i32 as (usize),
          0x1dd397i32 as (usize),
          0x1db97i32 as (usize),
          0x5db97i32 as (usize),
          0x9db97i32 as (usize),
          0xddb97i32 as (usize),
          0x11db97i32 as (usize),
          0x15db97i32 as (usize),
          0x19db97i32 as (usize),
          0x1ddb97i32 as (usize),
          0x1e397i32 as (usize),
          0x5e397i32 as (usize),
          0x9e397i32 as (usize),
          0xde397i32 as (usize),
          0x11e397i32 as (usize),
          0x15e397i32 as (usize),
          0x19e397i32 as (usize),
          0x1de397i32 as (usize),
          0x1eb97i32 as (usize),
          0x5eb97i32 as (usize),
          0x9eb97i32 as (usize),
          0xdeb97i32 as (usize),
          0x11eb97i32 as (usize),
          0x15eb97i32 as (usize),
          0x19eb97i32 as (usize),
          0x1deb97i32 as (usize),
          0x1f397i32 as (usize),
          0x5f397i32 as (usize),
          0x9f397i32 as (usize),
          0xdf397i32 as (usize),
          0x11f397i32 as (usize),
          0x15f397i32 as (usize),
          0x19f397i32 as (usize),
          0x1df397i32 as (usize),
          0x1fb97i32 as (usize),
          0x5fb97i32 as (usize),
          0x9fb97i32 as (usize),
          0xdfb97i32 as (usize),
          0x11fb97i32 as (usize),
          0x15fb97i32 as (usize),
          0x19fb97i32 as (usize),
          0x1dfb97i32 as (usize),
          0x1c3a7i32 as (usize),
          0x5c3a7i32 as (usize),
          0x9c3a7i32 as (usize),
          0xdc3a7i32 as (usize),
          0x11c3a7i32 as (usize),
          0x15c3a7i32 as (usize),
          0x19c3a7i32 as (usize),
          0x1dc3a7i32 as (usize),
          0x1cba7i32 as (usize),
          0x5cba7i32 as (usize),
          0x9cba7i32 as (usize),
          0xdcba7i32 as (usize),
          0x11cba7i32 as (usize),
          0x15cba7i32 as (usize),
          0x19cba7i32 as (usize),
          0x1dcba7i32 as (usize),
          0x1d3a7i32 as (usize),
          0x5d3a7i32 as (usize),
          0x9d3a7i32 as (usize),
          0xdd3a7i32 as (usize),
          0x11d3a7i32 as (usize),
          0x15d3a7i32 as (usize),
          0x19d3a7i32 as (usize),
          0x1dd3a7i32 as (usize),
          0x1dba7i32 as (usize),
          0x5dba7i32 as (usize),
          0x9dba7i32 as (usize),
          0xddba7i32 as (usize),
          0x11dba7i32 as (usize),
          0x15dba7i32 as (usize),
          0x19dba7i32 as (usize),
          0x1ddba7i32 as (usize),
          0x1e3a7i32 as (usize),
          0x5e3a7i32 as (usize),
          0x9e3a7i32 as (usize),
          0xde3a7i32 as (usize),
          0x11e3a7i32 as (usize),
          0x15e3a7i32 as (usize),
          0x19e3a7i32 as (usize),
          0x1de3a7i32 as (usize),
          0x1eba7i32 as (usize),
          0x5eba7i32 as (usize),
          0x9eba7i32 as (usize),
          0xdeba7i32 as (usize),
          0x11eba7i32 as (usize),
          0x15eba7i32 as (usize),
          0x19eba7i32 as (usize),
          0x1deba7i32 as (usize),
          0x1f3a7i32 as (usize),
          0x5f3a7i32 as (usize),
          0x9f3a7i32 as (usize),
          0xdf3a7i32 as (usize),
          0x11f3a7i32 as (usize),
          0x15f3a7i32 as (usize),
          0x19f3a7i32 as (usize),
          0x1df3a7i32 as (usize),
          0x1fba7i32 as (usize),
          0x5fba7i32 as (usize),
          0x9fba7i32 as (usize),
          0xdfba7i32 as (usize),
          0x11fba7i32 as (usize),
          0x15fba7i32 as (usize),
          0x19fba7i32 as (usize),
          0x1dfba7i32 as (usize),
          0x1c3b7i32 as (usize),
          0x5c3b7i32 as (usize),
          0x9c3b7i32 as (usize),
          0xdc3b7i32 as (usize),
          0x11c3b7i32 as (usize),
          0x15c3b7i32 as (usize),
          0x19c3b7i32 as (usize),
          0x1dc3b7i32 as (usize),
          0x1cbb7i32 as (usize),
          0x5cbb7i32 as (usize),
          0x9cbb7i32 as (usize),
          0xdcbb7i32 as (usize),
          0x11cbb7i32 as (usize),
          0x15cbb7i32 as (usize),
          0x19cbb7i32 as (usize),
          0x1dcbb7i32 as (usize),
          0x1d3b7i32 as (usize),
          0x5d3b7i32 as (usize),
          0x9d3b7i32 as (usize),
          0xdd3b7i32 as (usize),
          0x11d3b7i32 as (usize),
          0x15d3b7i32 as (usize),
          0x19d3b7i32 as (usize),
          0x1dd3b7i32 as (usize),
          0x1dbb7i32 as (usize),
          0x5dbb7i32 as (usize),
          0x9dbb7i32 as (usize),
          0xddbb7i32 as (usize),
          0x11dbb7i32 as (usize),
          0x15dbb7i32 as (usize),
          0x19dbb7i32 as (usize),
          0x1ddbb7i32 as (usize),
          0x1e3b7i32 as (usize),
          0x5e3b7i32 as (usize),
          0x9e3b7i32 as (usize),
          0xde3b7i32 as (usize),
          0x11e3b7i32 as (usize),
          0x15e3b7i32 as (usize),
          0x19e3b7i32 as (usize),
          0x1de3b7i32 as (usize),
          0x1ebb7i32 as (usize),
          0x5ebb7i32 as (usize),
          0x9ebb7i32 as (usize),
          0xdebb7i32 as (usize),
          0x11ebb7i32 as (usize),
          0x15ebb7i32 as (usize),
          0x19ebb7i32 as (usize),
          0x1debb7i32 as (usize),
          0x1f3b7i32 as (usize),
          0x5f3b7i32 as (usize),
          0x9f3b7i32 as (usize),
          0xdf3b7i32 as (usize),
          0x11f3b7i32 as (usize),
          0x15f3b7i32 as (usize),
          0x19f3b7i32 as (usize),
          0x1df3b7i32 as (usize),
          0x1fbb7i32 as (usize),
          0x5fbb7i32 as (usize),
          0x9fbb7i32 as (usize),
          0xdfbb7i32 as (usize),
          0x11fbb7i32 as (usize),
          0x15fbb7i32 as (usize),
          0x19fbb7i32 as (usize),
          0x1dfbb7i32 as (usize),
          0x1c3c7i32 as (usize),
          0x5c3c7i32 as (usize),
          0x9c3c7i32 as (usize),
          0xdc3c7i32 as (usize),
          0x11c3c7i32 as (usize),
          0x15c3c7i32 as (usize),
          0x19c3c7i32 as (usize),
          0x1dc3c7i32 as (usize),
          0x1cbc7i32 as (usize),
          0x5cbc7i32 as (usize),
          0x9cbc7i32 as (usize),
          0xdcbc7i32 as (usize),
          0x11cbc7i32 as (usize),
          0x15cbc7i32 as (usize),
          0x19cbc7i32 as (usize),
          0x1dcbc7i32 as (usize),
          0x1d3c7i32 as (usize),
          0x5d3c7i32 as (usize),
          0x9d3c7i32 as (usize),
          0xdd3c7i32 as (usize),
          0x11d3c7i32 as (usize),
          0x15d3c7i32 as (usize),
          0x19d3c7i32 as (usize),
          0x1dd3c7i32 as (usize),
          0x1dbc7i32 as (usize),
          0x5dbc7i32 as (usize),
          0x9dbc7i32 as (usize),
          0xddbc7i32 as (usize),
          0x11dbc7i32 as (usize),
          0x15dbc7i32 as (usize),
          0x19dbc7i32 as (usize),
          0x1ddbc7i32 as (usize),
          0x1e3c7i32 as (usize),
          0x5e3c7i32 as (usize),
          0x9e3c7i32 as (usize),
          0xde3c7i32 as (usize),
          0x11e3c7i32 as (usize),
          0x15e3c7i32 as (usize),
          0x19e3c7i32 as (usize),
          0x1de3c7i32 as (usize),
          0x1ebc7i32 as (usize),
          0x5ebc7i32 as (usize),
          0x9ebc7i32 as (usize),
          0xdebc7i32 as (usize),
          0x11ebc7i32 as (usize),
          0x15ebc7i32 as (usize),
          0x19ebc7i32 as (usize),
          0x1debc7i32 as (usize),
          0x1f3c7i32 as (usize),
          0x5f3c7i32 as (usize),
          0x9f3c7i32 as (usize),
          0xdf3c7i32 as (usize),
          0x11f3c7i32 as (usize),
          0x15f3c7i32 as (usize),
          0x19f3c7i32 as (usize),
          0x1df3c7i32 as (usize),
          0x1fbc7i32 as (usize),
          0x5fbc7i32 as (usize),
          0x9fbc7i32 as (usize),
          0xdfbc7i32 as (usize),
          0x11fbc7i32 as (usize),
          0x15fbc7i32 as (usize),
          0x19fbc7i32 as (usize),
          0x1dfbc7i32 as (usize),
          0x1c3d7i32 as (usize),
          0x5c3d7i32 as (usize),
          0x9c3d7i32 as (usize),
          0xdc3d7i32 as (usize),
          0x11c3d7i32 as (usize),
          0x15c3d7i32 as (usize),
          0x19c3d7i32 as (usize),
          0x1dc3d7i32 as (usize),
          0x1cbd7i32 as (usize),
          0x5cbd7i32 as (usize),
          0x9cbd7i32 as (usize),
          0xdcbd7i32 as (usize),
          0x11cbd7i32 as (usize),
          0x15cbd7i32 as (usize),
          0x19cbd7i32 as (usize),
          0x1dcbd7i32 as (usize),
          0x1d3d7i32 as (usize),
          0x5d3d7i32 as (usize),
          0x9d3d7i32 as (usize),
          0xdd3d7i32 as (usize),
          0x11d3d7i32 as (usize),
          0x15d3d7i32 as (usize),
          0x19d3d7i32 as (usize),
          0x1dd3d7i32 as (usize),
          0x1dbd7i32 as (usize),
          0x5dbd7i32 as (usize),
          0x9dbd7i32 as (usize),
          0xddbd7i32 as (usize),
          0x11dbd7i32 as (usize),
          0x15dbd7i32 as (usize),
          0x19dbd7i32 as (usize),
          0x1ddbd7i32 as (usize),
          0x1e3d7i32 as (usize),
          0x5e3d7i32 as (usize),
          0x9e3d7i32 as (usize),
          0xde3d7i32 as (usize),
          0x11e3d7i32 as (usize),
          0x15e3d7i32 as (usize),
          0x19e3d7i32 as (usize),
          0x1de3d7i32 as (usize),
          0x1ebd7i32 as (usize),
          0x5ebd7i32 as (usize),
          0x9ebd7i32 as (usize),
          0xdebd7i32 as (usize),
          0x11ebd7i32 as (usize),
          0x15ebd7i32 as (usize),
          0x19ebd7i32 as (usize),
          0x1debd7i32 as (usize),
          0x1f3d7i32 as (usize),
          0x5f3d7i32 as (usize),
          0x9f3d7i32 as (usize),
          0xdf3d7i32 as (usize),
          0x11f3d7i32 as (usize),
          0x15f3d7i32 as (usize),
          0x19f3d7i32 as (usize),
          0x1df3d7i32 as (usize),
          0x1fbd7i32 as (usize),
          0x5fbd7i32 as (usize),
          0x9fbd7i32 as (usize),
          0xdfbd7i32 as (usize),
          0x11fbd7i32 as (usize),
          0x15fbd7i32 as (usize),
          0x19fbd7i32 as (usize),
          0x1dfbd7i32 as (usize),
          0x1c3e7i32 as (usize),
          0x5c3e7i32 as (usize),
          0x9c3e7i32 as (usize),
          0xdc3e7i32 as (usize),
          0x11c3e7i32 as (usize),
          0x15c3e7i32 as (usize),
          0x19c3e7i32 as (usize),
          0x1dc3e7i32 as (usize),
          0x1cbe7i32 as (usize),
          0x5cbe7i32 as (usize),
          0x9cbe7i32 as (usize),
          0xdcbe7i32 as (usize),
          0x11cbe7i32 as (usize),
          0x15cbe7i32 as (usize),
          0x19cbe7i32 as (usize),
          0x1dcbe7i32 as (usize),
          0x1d3e7i32 as (usize),
          0x5d3e7i32 as (usize),
          0x9d3e7i32 as (usize),
          0xdd3e7i32 as (usize),
          0x11d3e7i32 as (usize),
          0x15d3e7i32 as (usize),
          0x19d3e7i32 as (usize),
          0x1dd3e7i32 as (usize),
          0x1dbe7i32 as (usize),
          0x5dbe7i32 as (usize),
          0x9dbe7i32 as (usize),
          0xddbe7i32 as (usize),
          0x11dbe7i32 as (usize),
          0x15dbe7i32 as (usize),
          0x19dbe7i32 as (usize),
          0x1ddbe7i32 as (usize),
          0x1e3e7i32 as (usize),
          0x5e3e7i32 as (usize),
          0x9e3e7i32 as (usize),
          0xde3e7i32 as (usize),
          0x11e3e7i32 as (usize),
          0x15e3e7i32 as (usize),
          0x19e3e7i32 as (usize),
          0x1de3e7i32 as (usize),
          0x1ebe7i32 as (usize),
          0x5ebe7i32 as (usize),
          0x9ebe7i32 as (usize),
          0xdebe7i32 as (usize),
          0x11ebe7i32 as (usize),
          0x15ebe7i32 as (usize),
          0x19ebe7i32 as (usize),
          0x1debe7i32 as (usize),
          0x1f3e7i32 as (usize),
          0x5f3e7i32 as (usize),
          0x9f3e7i32 as (usize),
          0xdf3e7i32 as (usize),
          0x11f3e7i32 as (usize),
          0x15f3e7i32 as (usize),
          0x19f3e7i32 as (usize),
          0x1df3e7i32 as (usize),
          0x1fbe7i32 as (usize),
          0x5fbe7i32 as (usize),
          0x9fbe7i32 as (usize),
          0xdfbe7i32 as (usize),
          0x11fbe7i32 as (usize),
          0x15fbe7i32 as (usize),
          0x19fbe7i32 as (usize),
          0x1dfbe7i32 as (usize),
          0x1c3f7i32 as (usize),
          0x5c3f7i32 as (usize),
          0x9c3f7i32 as (usize),
          0xdc3f7i32 as (usize),
          0x11c3f7i32 as (usize),
          0x15c3f7i32 as (usize),
          0x19c3f7i32 as (usize),
          0x1dc3f7i32 as (usize),
          0x1cbf7i32 as (usize),
          0x5cbf7i32 as (usize),
          0x9cbf7i32 as (usize),
          0xdcbf7i32 as (usize),
          0x11cbf7i32 as (usize),
          0x15cbf7i32 as (usize),
          0x19cbf7i32 as (usize),
          0x1dcbf7i32 as (usize),
          0x1d3f7i32 as (usize),
          0x5d3f7i32 as (usize),
          0x9d3f7i32 as (usize),
          0xdd3f7i32 as (usize),
          0x11d3f7i32 as (usize),
          0x15d3f7i32 as (usize),
          0x19d3f7i32 as (usize),
          0x1dd3f7i32 as (usize),
          0x1dbf7i32 as (usize),
          0x5dbf7i32 as (usize),
          0x9dbf7i32 as (usize),
          0xddbf7i32 as (usize),
          0x11dbf7i32 as (usize),
          0x15dbf7i32 as (usize),
          0x19dbf7i32 as (usize),
          0x1ddbf7i32 as (usize),
          0x1e3f7i32 as (usize),
          0x5e3f7i32 as (usize),
          0x9e3f7i32 as (usize),
          0xde3f7i32 as (usize),
          0x11e3f7i32 as (usize),
          0x15e3f7i32 as (usize),
          0x19e3f7i32 as (usize),
          0x1de3f7i32 as (usize),
          0x1ebf7i32 as (usize),
          0x5ebf7i32 as (usize),
          0x9ebf7i32 as (usize),
          0xdebf7i32 as (usize),
          0x11ebf7i32 as (usize),
          0x15ebf7i32 as (usize),
          0x19ebf7i32 as (usize),
          0x1debf7i32 as (usize),
          0x1f3f7i32 as (usize),
          0x5f3f7i32 as (usize),
          0x9f3f7i32 as (usize),
          0xdf3f7i32 as (usize),
          0x11f3f7i32 as (usize),
          0x15f3f7i32 as (usize),
          0x19f3f7i32 as (usize),
          0x1df3f7i32 as (usize),
          0x1fbf7i32 as (usize),
          0x5fbf7i32 as (usize),
          0x9fbf7i32 as (usize),
          0xdfbf7i32 as (usize),
          0x11fbf7i32 as (usize),
          0x15fbf7i32 as (usize),
          0x19fbf7i32 as (usize),
          0x1dfbf7i32 as (usize),
          0xe1c387i32 as (usize),
          0x2e1c387i32 as (usize),
          0x4e1c387i32 as (usize),
          0x6e1c387i32 as (usize),
          0x8e1c387i32 as (usize),
          0xae1c387i32 as (usize),
          0xce1c387i32 as (usize),
          0xee1c387i32 as (usize),
          0xe5c387i32 as (usize),
          0x2e5c387i32 as (usize),
          0x4e5c387i32 as (usize),
          0x6e5c387i32 as (usize),
          0x8e5c387i32 as (usize),
          0xae5c387i32 as (usize),
          0xce5c387i32 as (usize),
          0xee5c387i32 as (usize),
          0xe9c387i32 as (usize),
          0x2e9c387i32 as (usize),
          0x4e9c387i32 as (usize),
          0x6e9c387i32 as (usize),
          0x8e9c387i32 as (usize),
          0xae9c387i32 as (usize),
          0xce9c387i32 as (usize),
          0xee9c387i32 as (usize),
          0xedc387i32 as (usize),
          0x2edc387i32 as (usize),
          0x4edc387i32 as (usize),
          0x6edc387i32 as (usize),
          0x8edc387i32 as (usize),
          0xaedc387i32 as (usize),
          0xcedc387i32 as (usize),
          0xeedc387i32 as (usize),
          0xf1c387i32 as (usize),
          0x2f1c387i32 as (usize),
          0x4f1c387i32 as (usize),
          0x6f1c387i32 as (usize),
          0x8f1c387i32 as (usize),
          0xaf1c387i32 as (usize),
          0xcf1c387i32 as (usize),
          0xef1c387i32 as (usize),
          0xf5c387i32 as (usize),
          0x2f5c387i32 as (usize),
          0x4f5c387i32 as (usize),
          0x6f5c387i32 as (usize),
          0x8f5c387i32 as (usize),
          0xaf5c387i32 as (usize),
          0xcf5c387i32 as (usize),
          0xef5c387i32 as (usize),
          0xf9c387i32 as (usize),
          0x2f9c387i32 as (usize),
          0x4f9c387i32 as (usize),
          0x6f9c387i32 as (usize),
          0x8f9c387i32 as (usize),
          0xaf9c387i32 as (usize),
          0xcf9c387i32 as (usize),
          0xef9c387i32 as (usize),
          0xfdc387i32 as (usize),
          0x2fdc387i32 as (usize),
          0x4fdc387i32 as (usize),
          0x6fdc387i32 as (usize),
          0x8fdc387i32 as (usize),
          0xafdc387i32 as (usize),
          0xcfdc387i32 as (usize),
          0xefdc387i32 as (usize),
          0xe1cb87i32 as (usize),
          0x2e1cb87i32 as (usize),
          0x4e1cb87i32 as (usize),
          0x6e1cb87i32 as (usize),
          0x8e1cb87i32 as (usize),
          0xae1cb87i32 as (usize),
          0xce1cb87i32 as (usize),
          0xee1cb87i32 as (usize),
          0xe5cb87i32 as (usize),
          0x2e5cb87i32 as (usize),
          0x4e5cb87i32 as (usize),
          0x6e5cb87i32 as (usize),
          0x8e5cb87i32 as (usize),
          0xae5cb87i32 as (usize),
          0xce5cb87i32 as (usize),
          0xee5cb87i32 as (usize),
          0xe9cb87i32 as (usize),
          0x2e9cb87i32 as (usize),
          0x4e9cb87i32 as (usize),
          0x6e9cb87i32 as (usize),
          0x8e9cb87i32 as (usize),
          0xae9cb87i32 as (usize),
          0xce9cb87i32 as (usize),
          0xee9cb87i32 as (usize),
          0xedcb87i32 as (usize),
          0x2edcb87i32 as (usize),
          0x4edcb87i32 as (usize),
          0x6edcb87i32 as (usize),
          0x8edcb87i32 as (usize),
          0xaedcb87i32 as (usize),
          0xcedcb87i32 as (usize),
          0xeedcb87i32 as (usize),
          0xf1cb87i32 as (usize),
          0x2f1cb87i32 as (usize),
          0x4f1cb87i32 as (usize),
          0x6f1cb87i32 as (usize),
          0x8f1cb87i32 as (usize),
          0xaf1cb87i32 as (usize),
          0xcf1cb87i32 as (usize),
          0xef1cb87i32 as (usize),
          0xf5cb87i32 as (usize),
          0x2f5cb87i32 as (usize),
          0x4f5cb87i32 as (usize),
          0x6f5cb87i32 as (usize),
          0x8f5cb87i32 as (usize),
          0xaf5cb87i32 as (usize),
          0xcf5cb87i32 as (usize),
          0xef5cb87i32 as (usize),
          0xf9cb87i32 as (usize),
          0x2f9cb87i32 as (usize),
          0x4f9cb87i32 as (usize),
          0x6f9cb87i32 as (usize),
          0x8f9cb87i32 as (usize)
      ];

static mut kZeroRepsDepth
    : [u32; 704]
    = [   0i32 as (u32),
          4i32 as (u32),
          8i32 as (u32),
          7i32 as (u32),
          7i32 as (u32),
          7i32 as (u32),
          7i32 as (u32),
          7i32 as (u32),
          7i32 as (u32),
          7i32 as (u32),
          7i32 as (u32),
          11i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          14i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          21i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32),
          28i32 as (u32)
      ];

static mut kNonZeroRepsBits
    : [usize; 704]
    = [   0xbi32 as (usize),
          0x1bi32 as (usize),
          0x2bi32 as (usize),
          0x3bi32 as (usize),
          0x2cbi32 as (usize),
          0x6cbi32 as (usize),
          0xacbi32 as (usize),
          0xecbi32 as (usize),
          0x2dbi32 as (usize),
          0x6dbi32 as (usize),
          0xadbi32 as (usize),
          0xedbi32 as (usize),
          0x2ebi32 as (usize),
          0x6ebi32 as (usize),
          0xaebi32 as (usize),
          0xeebi32 as (usize),
          0x2fbi32 as (usize),
          0x6fbi32 as (usize),
          0xafbi32 as (usize),
          0xefbi32 as (usize),
          0xb2cbi32 as (usize),
          0x1b2cbi32 as (usize),
          0x2b2cbi32 as (usize),
          0x3b2cbi32 as (usize),
          0xb6cbi32 as (usize),
          0x1b6cbi32 as (usize),
          0x2b6cbi32 as (usize),
          0x3b6cbi32 as (usize),
          0xbacbi32 as (usize),
          0x1bacbi32 as (usize),
          0x2bacbi32 as (usize),
          0x3bacbi32 as (usize),
          0xbecbi32 as (usize),
          0x1becbi32 as (usize),
          0x2becbi32 as (usize),
          0x3becbi32 as (usize),
          0xb2dbi32 as (usize),
          0x1b2dbi32 as (usize),
          0x2b2dbi32 as (usize),
          0x3b2dbi32 as (usize),
          0xb6dbi32 as (usize),
          0x1b6dbi32 as (usize),
          0x2b6dbi32 as (usize),
          0x3b6dbi32 as (usize),
          0xbadbi32 as (usize),
          0x1badbi32 as (usize),
          0x2badbi32 as (usize),
          0x3badbi32 as (usize),
          0xbedbi32 as (usize),
          0x1bedbi32 as (usize),
          0x2bedbi32 as (usize),
          0x3bedbi32 as (usize),
          0xb2ebi32 as (usize),
          0x1b2ebi32 as (usize),
          0x2b2ebi32 as (usize),
          0x3b2ebi32 as (usize),
          0xb6ebi32 as (usize),
          0x1b6ebi32 as (usize),
          0x2b6ebi32 as (usize),
          0x3b6ebi32 as (usize),
          0xbaebi32 as (usize),
          0x1baebi32 as (usize),
          0x2baebi32 as (usize),
          0x3baebi32 as (usize),
          0xbeebi32 as (usize),
          0x1beebi32 as (usize),
          0x2beebi32 as (usize),
          0x3beebi32 as (usize),
          0xb2fbi32 as (usize),
          0x1b2fbi32 as (usize),
          0x2b2fbi32 as (usize),
          0x3b2fbi32 as (usize),
          0xb6fbi32 as (usize),
          0x1b6fbi32 as (usize),
          0x2b6fbi32 as (usize),
          0x3b6fbi32 as (usize),
          0xbafbi32 as (usize),
          0x1bafbi32 as (usize),
          0x2bafbi32 as (usize),
          0x3bafbi32 as (usize),
          0xbefbi32 as (usize),
          0x1befbi32 as (usize),
          0x2befbi32 as (usize),
          0x3befbi32 as (usize),
          0x2cb2cbi32 as (usize),
          0x6cb2cbi32 as (usize),
          0xacb2cbi32 as (usize),
          0xecb2cbi32 as (usize),
          0x2db2cbi32 as (usize),
          0x6db2cbi32 as (usize),
          0xadb2cbi32 as (usize),
          0xedb2cbi32 as (usize),
          0x2eb2cbi32 as (usize),
          0x6eb2cbi32 as (usize),
          0xaeb2cbi32 as (usize),
          0xeeb2cbi32 as (usize),
          0x2fb2cbi32 as (usize),
          0x6fb2cbi32 as (usize),
          0xafb2cbi32 as (usize),
          0xefb2cbi32 as (usize),
          0x2cb6cbi32 as (usize),
          0x6cb6cbi32 as (usize),
          0xacb6cbi32 as (usize),
          0xecb6cbi32 as (usize),
          0x2db6cbi32 as (usize),
          0x6db6cbi32 as (usize),
          0xadb6cbi32 as (usize),
          0xedb6cbi32 as (usize),
          0x2eb6cbi32 as (usize),
          0x6eb6cbi32 as (usize),
          0xaeb6cbi32 as (usize),
          0xeeb6cbi32 as (usize),
          0x2fb6cbi32 as (usize),
          0x6fb6cbi32 as (usize),
          0xafb6cbi32 as (usize),
          0xefb6cbi32 as (usize),
          0x2cbacbi32 as (usize),
          0x6cbacbi32 as (usize),
          0xacbacbi32 as (usize),
          0xecbacbi32 as (usize),
          0x2dbacbi32 as (usize),
          0x6dbacbi32 as (usize),
          0xadbacbi32 as (usize),
          0xedbacbi32 as (usize),
          0x2ebacbi32 as (usize),
          0x6ebacbi32 as (usize),
          0xaebacbi32 as (usize),
          0xeebacbi32 as (usize),
          0x2fbacbi32 as (usize),
          0x6fbacbi32 as (usize),
          0xafbacbi32 as (usize),
          0xefbacbi32 as (usize),
          0x2cbecbi32 as (usize),
          0x6cbecbi32 as (usize),
          0xacbecbi32 as (usize),
          0xecbecbi32 as (usize),
          0x2dbecbi32 as (usize),
          0x6dbecbi32 as (usize),
          0xadbecbi32 as (usize),
          0xedbecbi32 as (usize),
          0x2ebecbi32 as (usize),
          0x6ebecbi32 as (usize),
          0xaebecbi32 as (usize),
          0xeebecbi32 as (usize),
          0x2fbecbi32 as (usize),
          0x6fbecbi32 as (usize),
          0xafbecbi32 as (usize),
          0xefbecbi32 as (usize),
          0x2cb2dbi32 as (usize),
          0x6cb2dbi32 as (usize),
          0xacb2dbi32 as (usize),
          0xecb2dbi32 as (usize),
          0x2db2dbi32 as (usize),
          0x6db2dbi32 as (usize),
          0xadb2dbi32 as (usize),
          0xedb2dbi32 as (usize),
          0x2eb2dbi32 as (usize),
          0x6eb2dbi32 as (usize),
          0xaeb2dbi32 as (usize),
          0xeeb2dbi32 as (usize),
          0x2fb2dbi32 as (usize),
          0x6fb2dbi32 as (usize),
          0xafb2dbi32 as (usize),
          0xefb2dbi32 as (usize),
          0x2cb6dbi32 as (usize),
          0x6cb6dbi32 as (usize),
          0xacb6dbi32 as (usize),
          0xecb6dbi32 as (usize),
          0x2db6dbi32 as (usize),
          0x6db6dbi32 as (usize),
          0xadb6dbi32 as (usize),
          0xedb6dbi32 as (usize),
          0x2eb6dbi32 as (usize),
          0x6eb6dbi32 as (usize),
          0xaeb6dbi32 as (usize),
          0xeeb6dbi32 as (usize),
          0x2fb6dbi32 as (usize),
          0x6fb6dbi32 as (usize),
          0xafb6dbi32 as (usize),
          0xefb6dbi32 as (usize),
          0x2cbadbi32 as (usize),
          0x6cbadbi32 as (usize),
          0xacbadbi32 as (usize),
          0xecbadbi32 as (usize),
          0x2dbadbi32 as (usize),
          0x6dbadbi32 as (usize),
          0xadbadbi32 as (usize),
          0xedbadbi32 as (usize),
          0x2ebadbi32 as (usize),
          0x6ebadbi32 as (usize),
          0xaebadbi32 as (usize),
          0xeebadbi32 as (usize),
          0x2fbadbi32 as (usize),
          0x6fbadbi32 as (usize),
          0xafbadbi32 as (usize),
          0xefbadbi32 as (usize),
          0x2cbedbi32 as (usize),
          0x6cbedbi32 as (usize),
          0xacbedbi32 as (usize),
          0xecbedbi32 as (usize),
          0x2dbedbi32 as (usize),
          0x6dbedbi32 as (usize),
          0xadbedbi32 as (usize),
          0xedbedbi32 as (usize),
          0x2ebedbi32 as (usize),
          0x6ebedbi32 as (usize),
          0xaebedbi32 as (usize),
          0xeebedbi32 as (usize),
          0x2fbedbi32 as (usize),
          0x6fbedbi32 as (usize),
          0xafbedbi32 as (usize),
          0xefbedbi32 as (usize),
          0x2cb2ebi32 as (usize),
          0x6cb2ebi32 as (usize),
          0xacb2ebi32 as (usize),
          0xecb2ebi32 as (usize),
          0x2db2ebi32 as (usize),
          0x6db2ebi32 as (usize),
          0xadb2ebi32 as (usize),
          0xedb2ebi32 as (usize),
          0x2eb2ebi32 as (usize),
          0x6eb2ebi32 as (usize),
          0xaeb2ebi32 as (usize),
          0xeeb2ebi32 as (usize),
          0x2fb2ebi32 as (usize),
          0x6fb2ebi32 as (usize),
          0xafb2ebi32 as (usize),
          0xefb2ebi32 as (usize),
          0x2cb6ebi32 as (usize),
          0x6cb6ebi32 as (usize),
          0xacb6ebi32 as (usize),
          0xecb6ebi32 as (usize),
          0x2db6ebi32 as (usize),
          0x6db6ebi32 as (usize),
          0xadb6ebi32 as (usize),
          0xedb6ebi32 as (usize),
          0x2eb6ebi32 as (usize),
          0x6eb6ebi32 as (usize),
          0xaeb6ebi32 as (usize),
          0xeeb6ebi32 as (usize),
          0x2fb6ebi32 as (usize),
          0x6fb6ebi32 as (usize),
          0xafb6ebi32 as (usize),
          0xefb6ebi32 as (usize),
          0x2cbaebi32 as (usize),
          0x6cbaebi32 as (usize),
          0xacbaebi32 as (usize),
          0xecbaebi32 as (usize),
          0x2dbaebi32 as (usize),
          0x6dbaebi32 as (usize),
          0xadbaebi32 as (usize),
          0xedbaebi32 as (usize),
          0x2ebaebi32 as (usize),
          0x6ebaebi32 as (usize),
          0xaebaebi32 as (usize),
          0xeebaebi32 as (usize),
          0x2fbaebi32 as (usize),
          0x6fbaebi32 as (usize),
          0xafbaebi32 as (usize),
          0xefbaebi32 as (usize),
          0x2cbeebi32 as (usize),
          0x6cbeebi32 as (usize),
          0xacbeebi32 as (usize),
          0xecbeebi32 as (usize),
          0x2dbeebi32 as (usize),
          0x6dbeebi32 as (usize),
          0xadbeebi32 as (usize),
          0xedbeebi32 as (usize),
          0x2ebeebi32 as (usize),
          0x6ebeebi32 as (usize),
          0xaebeebi32 as (usize),
          0xeebeebi32 as (usize),
          0x2fbeebi32 as (usize),
          0x6fbeebi32 as (usize),
          0xafbeebi32 as (usize),
          0xefbeebi32 as (usize),
          0x2cb2fbi32 as (usize),
          0x6cb2fbi32 as (usize),
          0xacb2fbi32 as (usize),
          0xecb2fbi32 as (usize),
          0x2db2fbi32 as (usize),
          0x6db2fbi32 as (usize),
          0xadb2fbi32 as (usize),
          0xedb2fbi32 as (usize),
          0x2eb2fbi32 as (usize),
          0x6eb2fbi32 as (usize),
          0xaeb2fbi32 as (usize),
          0xeeb2fbi32 as (usize),
          0x2fb2fbi32 as (usize),
          0x6fb2fbi32 as (usize),
          0xafb2fbi32 as (usize),
          0xefb2fbi32 as (usize),
          0x2cb6fbi32 as (usize),
          0x6cb6fbi32 as (usize),
          0xacb6fbi32 as (usize),
          0xecb6fbi32 as (usize),
          0x2db6fbi32 as (usize),
          0x6db6fbi32 as (usize),
          0xadb6fbi32 as (usize),
          0xedb6fbi32 as (usize),
          0x2eb6fbi32 as (usize),
          0x6eb6fbi32 as (usize),
          0xaeb6fbi32 as (usize),
          0xeeb6fbi32 as (usize),
          0x2fb6fbi32 as (usize),
          0x6fb6fbi32 as (usize),
          0xafb6fbi32 as (usize),
          0xefb6fbi32 as (usize),
          0x2cbafbi32 as (usize),
          0x6cbafbi32 as (usize),
          0xacbafbi32 as (usize),
          0xecbafbi32 as (usize),
          0x2dbafbi32 as (usize),
          0x6dbafbi32 as (usize),
          0xadbafbi32 as (usize),
          0xedbafbi32 as (usize),
          0x2ebafbi32 as (usize),
          0x6ebafbi32 as (usize),
          0xaebafbi32 as (usize),
          0xeebafbi32 as (usize),
          0x2fbafbi32 as (usize),
          0x6fbafbi32 as (usize),
          0xafbafbi32 as (usize),
          0xefbafbi32 as (usize),
          0x2cbefbi32 as (usize),
          0x6cbefbi32 as (usize),
          0xacbefbi32 as (usize),
          0xecbefbi32 as (usize),
          0x2dbefbi32 as (usize),
          0x6dbefbi32 as (usize),
          0xadbefbi32 as (usize),
          0xedbefbi32 as (usize),
          0x2ebefbi32 as (usize),
          0x6ebefbi32 as (usize),
          0xaebefbi32 as (usize),
          0xeebefbi32 as (usize),
          0x2fbefbi32 as (usize),
          0x6fbefbi32 as (usize),
          0xafbefbi32 as (usize),
          0xefbefbi32 as (usize),
          0xb2cb2cbi32 as (usize),
          0x1b2cb2cbi32 as (usize),
          0x2b2cb2cbi32 as (usize),
          0x3b2cb2cbi32 as (usize),
          0xb6cb2cbi32 as (usize),
          0x1b6cb2cbi32 as (usize),
          0x2b6cb2cbi32 as (usize),
          0x3b6cb2cbi32 as (usize),
          0xbacb2cbi32 as (usize),
          0x1bacb2cbi32 as (usize),
          0x2bacb2cbi32 as (usize),
          0x3bacb2cbi32 as (usize),
          0xbecb2cbi32 as (usize),
          0x1becb2cbi32 as (usize),
          0x2becb2cbi32 as (usize),
          0x3becb2cbi32 as (usize),
          0xb2db2cbi32 as (usize),
          0x1b2db2cbi32 as (usize),
          0x2b2db2cbi32 as (usize),
          0x3b2db2cbi32 as (usize),
          0xb6db2cbi32 as (usize),
          0x1b6db2cbi32 as (usize),
          0x2b6db2cbi32 as (usize),
          0x3b6db2cbi32 as (usize),
          0xbadb2cbi32 as (usize),
          0x1badb2cbi32 as (usize),
          0x2badb2cbi32 as (usize),
          0x3badb2cbi32 as (usize),
          0xbedb2cbi32 as (usize),
          0x1bedb2cbi32 as (usize),
          0x2bedb2cbi32 as (usize),
          0x3bedb2cbi32 as (usize),
          0xb2eb2cbi32 as (usize),
          0x1b2eb2cbi32 as (usize),
          0x2b2eb2cbi32 as (usize),
          0x3b2eb2cbi32 as (usize),
          0xb6eb2cbi32 as (usize),
          0x1b6eb2cbi32 as (usize),
          0x2b6eb2cbi32 as (usize),
          0x3b6eb2cbi32 as (usize),
          0xbaeb2cbi32 as (usize),
          0x1baeb2cbi32 as (usize),
          0x2baeb2cbi32 as (usize),
          0x3baeb2cbi32 as (usize),
          0xbeeb2cbi32 as (usize),
          0x1beeb2cbi32 as (usize),
          0x2beeb2cbi32 as (usize),
          0x3beeb2cbi32 as (usize),
          0xb2fb2cbi32 as (usize),
          0x1b2fb2cbi32 as (usize),
          0x2b2fb2cbi32 as (usize),
          0x3b2fb2cbi32 as (usize),
          0xb6fb2cbi32 as (usize),
          0x1b6fb2cbi32 as (usize),
          0x2b6fb2cbi32 as (usize),
          0x3b6fb2cbi32 as (usize),
          0xbafb2cbi32 as (usize),
          0x1bafb2cbi32 as (usize),
          0x2bafb2cbi32 as (usize),
          0x3bafb2cbi32 as (usize),
          0xbefb2cbi32 as (usize),
          0x1befb2cbi32 as (usize),
          0x2befb2cbi32 as (usize),
          0x3befb2cbi32 as (usize),
          0xb2cb6cbi32 as (usize),
          0x1b2cb6cbi32 as (usize),
          0x2b2cb6cbi32 as (usize),
          0x3b2cb6cbi32 as (usize),
          0xb6cb6cbi32 as (usize),
          0x1b6cb6cbi32 as (usize),
          0x2b6cb6cbi32 as (usize),
          0x3b6cb6cbi32 as (usize),
          0xbacb6cbi32 as (usize),
          0x1bacb6cbi32 as (usize),
          0x2bacb6cbi32 as (usize),
          0x3bacb6cbi32 as (usize),
          0xbecb6cbi32 as (usize),
          0x1becb6cbi32 as (usize),
          0x2becb6cbi32 as (usize),
          0x3becb6cbi32 as (usize),
          0xb2db6cbi32 as (usize),
          0x1b2db6cbi32 as (usize),
          0x2b2db6cbi32 as (usize),
          0x3b2db6cbi32 as (usize),
          0xb6db6cbi32 as (usize),
          0x1b6db6cbi32 as (usize),
          0x2b6db6cbi32 as (usize),
          0x3b6db6cbi32 as (usize),
          0xbadb6cbi32 as (usize),
          0x1badb6cbi32 as (usize),
          0x2badb6cbi32 as (usize),
          0x3badb6cbi32 as (usize),
          0xbedb6cbi32 as (usize),
          0x1bedb6cbi32 as (usize),
          0x2bedb6cbi32 as (usize),
          0x3bedb6cbi32 as (usize),
          0xb2eb6cbi32 as (usize),
          0x1b2eb6cbi32 as (usize),
          0x2b2eb6cbi32 as (usize),
          0x3b2eb6cbi32 as (usize),
          0xb6eb6cbi32 as (usize),
          0x1b6eb6cbi32 as (usize),
          0x2b6eb6cbi32 as (usize),
          0x3b6eb6cbi32 as (usize),
          0xbaeb6cbi32 as (usize),
          0x1baeb6cbi32 as (usize),
          0x2baeb6cbi32 as (usize),
          0x3baeb6cbi32 as (usize),
          0xbeeb6cbi32 as (usize),
          0x1beeb6cbi32 as (usize),
          0x2beeb6cbi32 as (usize),
          0x3beeb6cbi32 as (usize),
          0xb2fb6cbi32 as (usize),
          0x1b2fb6cbi32 as (usize),
          0x2b2fb6cbi32 as (usize),
          0x3b2fb6cbi32 as (usize),
          0xb6fb6cbi32 as (usize),
          0x1b6fb6cbi32 as (usize),
          0x2b6fb6cbi32 as (usize),
          0x3b6fb6cbi32 as (usize),
          0xbafb6cbi32 as (usize),
          0x1bafb6cbi32 as (usize),
          0x2bafb6cbi32 as (usize),
          0x3bafb6cbi32 as (usize),
          0xbefb6cbi32 as (usize),
          0x1befb6cbi32 as (usize),
          0x2befb6cbi32 as (usize),
          0x3befb6cbi32 as (usize),
          0xb2cbacbi32 as (usize),
          0x1b2cbacbi32 as (usize),
          0x2b2cbacbi32 as (usize),
          0x3b2cbacbi32 as (usize),
          0xb6cbacbi32 as (usize),
          0x1b6cbacbi32 as (usize),
          0x2b6cbacbi32 as (usize),
          0x3b6cbacbi32 as (usize),
          0xbacbacbi32 as (usize),
          0x1bacbacbi32 as (usize),
          0x2bacbacbi32 as (usize),
          0x3bacbacbi32 as (usize),
          0xbecbacbi32 as (usize),
          0x1becbacbi32 as (usize),
          0x2becbacbi32 as (usize),
          0x3becbacbi32 as (usize),
          0xb2dbacbi32 as (usize),
          0x1b2dbacbi32 as (usize),
          0x2b2dbacbi32 as (usize),
          0x3b2dbacbi32 as (usize),
          0xb6dbacbi32 as (usize),
          0x1b6dbacbi32 as (usize),
          0x2b6dbacbi32 as (usize),
          0x3b6dbacbi32 as (usize),
          0xbadbacbi32 as (usize),
          0x1badbacbi32 as (usize),
          0x2badbacbi32 as (usize),
          0x3badbacbi32 as (usize),
          0xbedbacbi32 as (usize),
          0x1bedbacbi32 as (usize),
          0x2bedbacbi32 as (usize),
          0x3bedbacbi32 as (usize),
          0xb2ebacbi32 as (usize),
          0x1b2ebacbi32 as (usize),
          0x2b2ebacbi32 as (usize),
          0x3b2ebacbi32 as (usize),
          0xb6ebacbi32 as (usize),
          0x1b6ebacbi32 as (usize),
          0x2b6ebacbi32 as (usize),
          0x3b6ebacbi32 as (usize),
          0xbaebacbi32 as (usize),
          0x1baebacbi32 as (usize),
          0x2baebacbi32 as (usize),
          0x3baebacbi32 as (usize),
          0xbeebacbi32 as (usize),
          0x1beebacbi32 as (usize),
          0x2beebacbi32 as (usize),
          0x3beebacbi32 as (usize),
          0xb2fbacbi32 as (usize),
          0x1b2fbacbi32 as (usize),
          0x2b2fbacbi32 as (usize),
          0x3b2fbacbi32 as (usize),
          0xb6fbacbi32 as (usize),
          0x1b6fbacbi32 as (usize),
          0x2b6fbacbi32 as (usize),
          0x3b6fbacbi32 as (usize),
          0xbafbacbi32 as (usize),
          0x1bafbacbi32 as (usize),
          0x2bafbacbi32 as (usize),
          0x3bafbacbi32 as (usize),
          0xbefbacbi32 as (usize),
          0x1befbacbi32 as (usize),
          0x2befbacbi32 as (usize),
          0x3befbacbi32 as (usize),
          0xb2cbecbi32 as (usize),
          0x1b2cbecbi32 as (usize),
          0x2b2cbecbi32 as (usize),
          0x3b2cbecbi32 as (usize),
          0xb6cbecbi32 as (usize),
          0x1b6cbecbi32 as (usize),
          0x2b6cbecbi32 as (usize),
          0x3b6cbecbi32 as (usize),
          0xbacbecbi32 as (usize),
          0x1bacbecbi32 as (usize),
          0x2bacbecbi32 as (usize),
          0x3bacbecbi32 as (usize),
          0xbecbecbi32 as (usize),
          0x1becbecbi32 as (usize),
          0x2becbecbi32 as (usize),
          0x3becbecbi32 as (usize),
          0xb2dbecbi32 as (usize),
          0x1b2dbecbi32 as (usize),
          0x2b2dbecbi32 as (usize),
          0x3b2dbecbi32 as (usize),
          0xb6dbecbi32 as (usize),
          0x1b6dbecbi32 as (usize),
          0x2b6dbecbi32 as (usize),
          0x3b6dbecbi32 as (usize),
          0xbadbecbi32 as (usize),
          0x1badbecbi32 as (usize),
          0x2badbecbi32 as (usize),
          0x3badbecbi32 as (usize),
          0xbedbecbi32 as (usize),
          0x1bedbecbi32 as (usize),
          0x2bedbecbi32 as (usize),
          0x3bedbecbi32 as (usize),
          0xb2ebecbi32 as (usize),
          0x1b2ebecbi32 as (usize),
          0x2b2ebecbi32 as (usize),
          0x3b2ebecbi32 as (usize),
          0xb6ebecbi32 as (usize),
          0x1b6ebecbi32 as (usize),
          0x2b6ebecbi32 as (usize),
          0x3b6ebecbi32 as (usize),
          0xbaebecbi32 as (usize),
          0x1baebecbi32 as (usize),
          0x2baebecbi32 as (usize),
          0x3baebecbi32 as (usize),
          0xbeebecbi32 as (usize),
          0x1beebecbi32 as (usize),
          0x2beebecbi32 as (usize),
          0x3beebecbi32 as (usize),
          0xb2fbecbi32 as (usize),
          0x1b2fbecbi32 as (usize),
          0x2b2fbecbi32 as (usize),
          0x3b2fbecbi32 as (usize),
          0xb6fbecbi32 as (usize),
          0x1b6fbecbi32 as (usize),
          0x2b6fbecbi32 as (usize),
          0x3b6fbecbi32 as (usize),
          0xbafbecbi32 as (usize),
          0x1bafbecbi32 as (usize),
          0x2bafbecbi32 as (usize),
          0x3bafbecbi32 as (usize),
          0xbefbecbi32 as (usize),
          0x1befbecbi32 as (usize),
          0x2befbecbi32 as (usize),
          0x3befbecbi32 as (usize),
          0xb2cb2dbi32 as (usize),
          0x1b2cb2dbi32 as (usize),
          0x2b2cb2dbi32 as (usize),
          0x3b2cb2dbi32 as (usize),
          0xb6cb2dbi32 as (usize),
          0x1b6cb2dbi32 as (usize),
          0x2b6cb2dbi32 as (usize),
          0x3b6cb2dbi32 as (usize),
          0xbacb2dbi32 as (usize),
          0x1bacb2dbi32 as (usize),
          0x2bacb2dbi32 as (usize),
          0x3bacb2dbi32 as (usize),
          0xbecb2dbi32 as (usize),
          0x1becb2dbi32 as (usize),
          0x2becb2dbi32 as (usize),
          0x3becb2dbi32 as (usize),
          0xb2db2dbi32 as (usize),
          0x1b2db2dbi32 as (usize),
          0x2b2db2dbi32 as (usize),
          0x3b2db2dbi32 as (usize),
          0xb6db2dbi32 as (usize),
          0x1b6db2dbi32 as (usize),
          0x2b6db2dbi32 as (usize),
          0x3b6db2dbi32 as (usize),
          0xbadb2dbi32 as (usize),
          0x1badb2dbi32 as (usize),
          0x2badb2dbi32 as (usize),
          0x3badb2dbi32 as (usize),
          0xbedb2dbi32 as (usize),
          0x1bedb2dbi32 as (usize),
          0x2bedb2dbi32 as (usize),
          0x3bedb2dbi32 as (usize),
          0xb2eb2dbi32 as (usize),
          0x1b2eb2dbi32 as (usize),
          0x2b2eb2dbi32 as (usize),
          0x3b2eb2dbi32 as (usize),
          0xb6eb2dbi32 as (usize),
          0x1b6eb2dbi32 as (usize),
          0x2b6eb2dbi32 as (usize),
          0x3b6eb2dbi32 as (usize),
          0xbaeb2dbi32 as (usize),
          0x1baeb2dbi32 as (usize),
          0x2baeb2dbi32 as (usize),
          0x3baeb2dbi32 as (usize),
          0xbeeb2dbi32 as (usize),
          0x1beeb2dbi32 as (usize),
          0x2beeb2dbi32 as (usize),
          0x3beeb2dbi32 as (usize),
          0xb2fb2dbi32 as (usize),
          0x1b2fb2dbi32 as (usize),
          0x2b2fb2dbi32 as (usize),
          0x3b2fb2dbi32 as (usize),
          0xb6fb2dbi32 as (usize),
          0x1b6fb2dbi32 as (usize),
          0x2b6fb2dbi32 as (usize),
          0x3b6fb2dbi32 as (usize),
          0xbafb2dbi32 as (usize),
          0x1bafb2dbi32 as (usize),
          0x2bafb2dbi32 as (usize),
          0x3bafb2dbi32 as (usize),
          0xbefb2dbi32 as (usize),
          0x1befb2dbi32 as (usize),
          0x2befb2dbi32 as (usize),
          0x3befb2dbi32 as (usize),
          0xb2cb6dbi32 as (usize),
          0x1b2cb6dbi32 as (usize),
          0x2b2cb6dbi32 as (usize),
          0x3b2cb6dbi32 as (usize),
          0xb6cb6dbi32 as (usize),
          0x1b6cb6dbi32 as (usize),
          0x2b6cb6dbi32 as (usize),
          0x3b6cb6dbi32 as (usize),
          0xbacb6dbi32 as (usize),
          0x1bacb6dbi32 as (usize),
          0x2bacb6dbi32 as (usize),
          0x3bacb6dbi32 as (usize),
          0xbecb6dbi32 as (usize),
          0x1becb6dbi32 as (usize),
          0x2becb6dbi32 as (usize),
          0x3becb6dbi32 as (usize),
          0xb2db6dbi32 as (usize),
          0x1b2db6dbi32 as (usize),
          0x2b2db6dbi32 as (usize),
          0x3b2db6dbi32 as (usize),
          0xb6db6dbi32 as (usize),
          0x1b6db6dbi32 as (usize),
          0x2b6db6dbi32 as (usize),
          0x3b6db6dbi32 as (usize),
          0xbadb6dbi32 as (usize),
          0x1badb6dbi32 as (usize),
          0x2badb6dbi32 as (usize),
          0x3badb6dbi32 as (usize),
          0xbedb6dbi32 as (usize),
          0x1bedb6dbi32 as (usize),
          0x2bedb6dbi32 as (usize),
          0x3bedb6dbi32 as (usize),
          0xb2eb6dbi32 as (usize),
          0x1b2eb6dbi32 as (usize),
          0x2b2eb6dbi32 as (usize),
          0x3b2eb6dbi32 as (usize),
          0xb6eb6dbi32 as (usize),
          0x1b6eb6dbi32 as (usize),
          0x2b6eb6dbi32 as (usize),
          0x3b6eb6dbi32 as (usize),
          0xbaeb6dbi32 as (usize),
          0x1baeb6dbi32 as (usize),
          0x2baeb6dbi32 as (usize),
          0x3baeb6dbi32 as (usize)
      ];

static mut kNonZeroRepsDepth
    : [u32; 704]
    = [   6i32 as (u32),
          6i32 as (u32),
          6i32 as (u32),
          6i32 as (u32),
          12i32 as (u32),
          12i32 as (u32),
          12i32 as (u32),
          12i32 as (u32),
          12i32 as (u32),
          12i32 as (u32),
          12i32 as (u32),
          12i32 as (u32),
          12i32 as (u32),
          12i32 as (u32),
          12i32 as (u32),
          12i32 as (u32),
          12i32 as (u32),
          12i32 as (u32),
          12i32 as (u32),
          12i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          18i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          24i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32),
          30i32 as (u32)
      ];

static mut kStaticCommandCodeBits
    : [u16; 704]
    = [   0i32 as (u16),
          256i32 as (u16),
          128i32 as (u16),
          384i32 as (u16),
          64i32 as (u16),
          320i32 as (u16),
          192i32 as (u16),
          448i32 as (u16),
          32i32 as (u16),
          288i32 as (u16),
          160i32 as (u16),
          416i32 as (u16),
          96i32 as (u16),
          352i32 as (u16),
          224i32 as (u16),
          480i32 as (u16),
          16i32 as (u16),
          272i32 as (u16),
          144i32 as (u16),
          400i32 as (u16),
          80i32 as (u16),
          336i32 as (u16),
          208i32 as (u16),
          464i32 as (u16),
          48i32 as (u16),
          304i32 as (u16),
          176i32 as (u16),
          432i32 as (u16),
          112i32 as (u16),
          368i32 as (u16),
          240i32 as (u16),
          496i32 as (u16),
          8i32 as (u16),
          264i32 as (u16),
          136i32 as (u16),
          392i32 as (u16),
          72i32 as (u16),
          328i32 as (u16),
          200i32 as (u16),
          456i32 as (u16),
          40i32 as (u16),
          296i32 as (u16),
          168i32 as (u16),
          424i32 as (u16),
          104i32 as (u16),
          360i32 as (u16),
          232i32 as (u16),
          488i32 as (u16),
          24i32 as (u16),
          280i32 as (u16),
          152i32 as (u16),
          408i32 as (u16),
          88i32 as (u16),
          344i32 as (u16),
          216i32 as (u16),
          472i32 as (u16),
          56i32 as (u16),
          312i32 as (u16),
          184i32 as (u16),
          440i32 as (u16),
          120i32 as (u16),
          376i32 as (u16),
          248i32 as (u16),
          504i32 as (u16),
          4i32 as (u16),
          260i32 as (u16),
          132i32 as (u16),
          388i32 as (u16),
          68i32 as (u16),
          324i32 as (u16),
          196i32 as (u16),
          452i32 as (u16),
          36i32 as (u16),
          292i32 as (u16),
          164i32 as (u16),
          420i32 as (u16),
          100i32 as (u16),
          356i32 as (u16),
          228i32 as (u16),
          484i32 as (u16),
          20i32 as (u16),
          276i32 as (u16),
          148i32 as (u16),
          404i32 as (u16),
          84i32 as (u16),
          340i32 as (u16),
          212i32 as (u16),
          468i32 as (u16),
          52i32 as (u16),
          308i32 as (u16),
          180i32 as (u16),
          436i32 as (u16),
          116i32 as (u16),
          372i32 as (u16),
          244i32 as (u16),
          500i32 as (u16),
          12i32 as (u16),
          268i32 as (u16),
          140i32 as (u16),
          396i32 as (u16),
          76i32 as (u16),
          332i32 as (u16),
          204i32 as (u16),
          460i32 as (u16),
          44i32 as (u16),
          300i32 as (u16),
          172i32 as (u16),
          428i32 as (u16),
          108i32 as (u16),
          364i32 as (u16),
          236i32 as (u16),
          492i32 as (u16),
          28i32 as (u16),
          284i32 as (u16),
          156i32 as (u16),
          412i32 as (u16),
          92i32 as (u16),
          348i32 as (u16),
          220i32 as (u16),
          476i32 as (u16),
          60i32 as (u16),
          316i32 as (u16),
          188i32 as (u16),
          444i32 as (u16),
          124i32 as (u16),
          380i32 as (u16),
          252i32 as (u16),
          508i32 as (u16),
          2i32 as (u16),
          258i32 as (u16),
          130i32 as (u16),
          386i32 as (u16),
          66i32 as (u16),
          322i32 as (u16),
          194i32 as (u16),
          450i32 as (u16),
          34i32 as (u16),
          290i32 as (u16),
          162i32 as (u16),
          418i32 as (u16),
          98i32 as (u16),
          354i32 as (u16),
          226i32 as (u16),
          482i32 as (u16),
          18i32 as (u16),
          274i32 as (u16),
          146i32 as (u16),
          402i32 as (u16),
          82i32 as (u16),
          338i32 as (u16),
          210i32 as (u16),
          466i32 as (u16),
          50i32 as (u16),
          306i32 as (u16),
          178i32 as (u16),
          434i32 as (u16),
          114i32 as (u16),
          370i32 as (u16),
          242i32 as (u16),
          498i32 as (u16),
          10i32 as (u16),
          266i32 as (u16),
          138i32 as (u16),
          394i32 as (u16),
          74i32 as (u16),
          330i32 as (u16),
          202i32 as (u16),
          458i32 as (u16),
          42i32 as (u16),
          298i32 as (u16),
          170i32 as (u16),
          426i32 as (u16),
          106i32 as (u16),
          362i32 as (u16),
          234i32 as (u16),
          490i32 as (u16),
          26i32 as (u16),
          282i32 as (u16),
          154i32 as (u16),
          410i32 as (u16),
          90i32 as (u16),
          346i32 as (u16),
          218i32 as (u16),
          474i32 as (u16),
          58i32 as (u16),
          314i32 as (u16),
          186i32 as (u16),
          442i32 as (u16),
          122i32 as (u16),
          378i32 as (u16),
          250i32 as (u16),
          506i32 as (u16),
          6i32 as (u16),
          262i32 as (u16),
          134i32 as (u16),
          390i32 as (u16),
          70i32 as (u16),
          326i32 as (u16),
          198i32 as (u16),
          454i32 as (u16),
          38i32 as (u16),
          294i32 as (u16),
          166i32 as (u16),
          422i32 as (u16),
          102i32 as (u16),
          358i32 as (u16),
          230i32 as (u16),
          486i32 as (u16),
          22i32 as (u16),
          278i32 as (u16),
          150i32 as (u16),
          406i32 as (u16),
          86i32 as (u16),
          342i32 as (u16),
          214i32 as (u16),
          470i32 as (u16),
          54i32 as (u16),
          310i32 as (u16),
          182i32 as (u16),
          438i32 as (u16),
          118i32 as (u16),
          374i32 as (u16),
          246i32 as (u16),
          502i32 as (u16),
          14i32 as (u16),
          270i32 as (u16),
          142i32 as (u16),
          398i32 as (u16),
          78i32 as (u16),
          334i32 as (u16),
          206i32 as (u16),
          462i32 as (u16),
          46i32 as (u16),
          302i32 as (u16),
          174i32 as (u16),
          430i32 as (u16),
          110i32 as (u16),
          366i32 as (u16),
          238i32 as (u16),
          494i32 as (u16),
          30i32 as (u16),
          286i32 as (u16),
          158i32 as (u16),
          414i32 as (u16),
          94i32 as (u16),
          350i32 as (u16),
          222i32 as (u16),
          478i32 as (u16),
          62i32 as (u16),
          318i32 as (u16),
          190i32 as (u16),
          446i32 as (u16),
          126i32 as (u16),
          382i32 as (u16),
          254i32 as (u16),
          510i32 as (u16),
          1i32 as (u16),
          257i32 as (u16),
          129i32 as (u16),
          385i32 as (u16),
          65i32 as (u16),
          321i32 as (u16),
          193i32 as (u16),
          449i32 as (u16),
          33i32 as (u16),
          289i32 as (u16),
          161i32 as (u16),
          417i32 as (u16),
          97i32 as (u16),
          353i32 as (u16),
          225i32 as (u16),
          481i32 as (u16),
          17i32 as (u16),
          273i32 as (u16),
          145i32 as (u16),
          401i32 as (u16),
          81i32 as (u16),
          337i32 as (u16),
          209i32 as (u16),
          465i32 as (u16),
          49i32 as (u16),
          305i32 as (u16),
          177i32 as (u16),
          433i32 as (u16),
          113i32 as (u16),
          369i32 as (u16),
          241i32 as (u16),
          497i32 as (u16),
          9i32 as (u16),
          265i32 as (u16),
          137i32 as (u16),
          393i32 as (u16),
          73i32 as (u16),
          329i32 as (u16),
          201i32 as (u16),
          457i32 as (u16),
          41i32 as (u16),
          297i32 as (u16),
          169i32 as (u16),
          425i32 as (u16),
          105i32 as (u16),
          361i32 as (u16),
          233i32 as (u16),
          489i32 as (u16),
          25i32 as (u16),
          281i32 as (u16),
          153i32 as (u16),
          409i32 as (u16),
          89i32 as (u16),
          345i32 as (u16),
          217i32 as (u16),
          473i32 as (u16),
          57i32 as (u16),
          313i32 as (u16),
          185i32 as (u16),
          441i32 as (u16),
          121i32 as (u16),
          377i32 as (u16),
          249i32 as (u16),
          505i32 as (u16),
          5i32 as (u16),
          261i32 as (u16),
          133i32 as (u16),
          389i32 as (u16),
          69i32 as (u16),
          325i32 as (u16),
          197i32 as (u16),
          453i32 as (u16),
          37i32 as (u16),
          293i32 as (u16),
          165i32 as (u16),
          421i32 as (u16),
          101i32 as (u16),
          357i32 as (u16),
          229i32 as (u16),
          485i32 as (u16),
          21i32 as (u16),
          277i32 as (u16),
          149i32 as (u16),
          405i32 as (u16),
          85i32 as (u16),
          341i32 as (u16),
          213i32 as (u16),
          469i32 as (u16),
          53i32 as (u16),
          309i32 as (u16),
          181i32 as (u16),
          437i32 as (u16),
          117i32 as (u16),
          373i32 as (u16),
          245i32 as (u16),
          501i32 as (u16),
          13i32 as (u16),
          269i32 as (u16),
          141i32 as (u16),
          397i32 as (u16),
          77i32 as (u16),
          333i32 as (u16),
          205i32 as (u16),
          461i32 as (u16),
          45i32 as (u16),
          301i32 as (u16),
          173i32 as (u16),
          429i32 as (u16),
          109i32 as (u16),
          365i32 as (u16),
          237i32 as (u16),
          493i32 as (u16),
          29i32 as (u16),
          285i32 as (u16),
          157i32 as (u16),
          413i32 as (u16),
          93i32 as (u16),
          349i32 as (u16),
          221i32 as (u16),
          477i32 as (u16),
          61i32 as (u16),
          317i32 as (u16),
          189i32 as (u16),
          445i32 as (u16),
          125i32 as (u16),
          381i32 as (u16),
          253i32 as (u16),
          509i32 as (u16),
          3i32 as (u16),
          259i32 as (u16),
          131i32 as (u16),
          387i32 as (u16),
          67i32 as (u16),
          323i32 as (u16),
          195i32 as (u16),
          451i32 as (u16),
          35i32 as (u16),
          291i32 as (u16),
          163i32 as (u16),
          419i32 as (u16),
          99i32 as (u16),
          355i32 as (u16),
          227i32 as (u16),
          483i32 as (u16),
          19i32 as (u16),
          275i32 as (u16),
          147i32 as (u16),
          403i32 as (u16),
          83i32 as (u16),
          339i32 as (u16),
          211i32 as (u16),
          467i32 as (u16),
          51i32 as (u16),
          307i32 as (u16),
          179i32 as (u16),
          435i32 as (u16),
          115i32 as (u16),
          371i32 as (u16),
          243i32 as (u16),
          499i32 as (u16),
          11i32 as (u16),
          267i32 as (u16),
          139i32 as (u16),
          395i32 as (u16),
          75i32 as (u16),
          331i32 as (u16),
          203i32 as (u16),
          459i32 as (u16),
          43i32 as (u16),
          299i32 as (u16),
          171i32 as (u16),
          427i32 as (u16),
          107i32 as (u16),
          363i32 as (u16),
          235i32 as (u16),
          491i32 as (u16),
          27i32 as (u16),
          283i32 as (u16),
          155i32 as (u16),
          411i32 as (u16),
          91i32 as (u16),
          347i32 as (u16),
          219i32 as (u16),
          475i32 as (u16),
          59i32 as (u16),
          315i32 as (u16),
          187i32 as (u16),
          443i32 as (u16),
          123i32 as (u16),
          379i32 as (u16),
          251i32 as (u16),
          507i32 as (u16),
          7i32 as (u16),
          1031i32 as (u16),
          519i32 as (u16),
          1543i32 as (u16),
          263i32 as (u16),
          1287i32 as (u16),
          775i32 as (u16),
          1799i32 as (u16),
          135i32 as (u16),
          1159i32 as (u16),
          647i32 as (u16),
          1671i32 as (u16),
          391i32 as (u16),
          1415i32 as (u16),
          903i32 as (u16),
          1927i32 as (u16),
          71i32 as (u16),
          1095i32 as (u16),
          583i32 as (u16),
          1607i32 as (u16),
          327i32 as (u16),
          1351i32 as (u16),
          839i32 as (u16),
          1863i32 as (u16),
          199i32 as (u16),
          1223i32 as (u16),
          711i32 as (u16),
          1735i32 as (u16),
          455i32 as (u16),
          1479i32 as (u16),
          967i32 as (u16),
          1991i32 as (u16),
          39i32 as (u16),
          1063i32 as (u16),
          551i32 as (u16),
          1575i32 as (u16),
          295i32 as (u16),
          1319i32 as (u16),
          807i32 as (u16),
          1831i32 as (u16),
          167i32 as (u16),
          1191i32 as (u16),
          679i32 as (u16),
          1703i32 as (u16),
          423i32 as (u16),
          1447i32 as (u16),
          935i32 as (u16),
          1959i32 as (u16),
          103i32 as (u16),
          1127i32 as (u16),
          615i32 as (u16),
          1639i32 as (u16),
          359i32 as (u16),
          1383i32 as (u16),
          871i32 as (u16),
          1895i32 as (u16),
          231i32 as (u16),
          1255i32 as (u16),
          743i32 as (u16),
          1767i32 as (u16),
          487i32 as (u16),
          1511i32 as (u16),
          999i32 as (u16),
          2023i32 as (u16),
          23i32 as (u16),
          1047i32 as (u16),
          535i32 as (u16),
          1559i32 as (u16),
          279i32 as (u16),
          1303i32 as (u16),
          791i32 as (u16),
          1815i32 as (u16),
          151i32 as (u16),
          1175i32 as (u16),
          663i32 as (u16),
          1687i32 as (u16),
          407i32 as (u16),
          1431i32 as (u16),
          919i32 as (u16),
          1943i32 as (u16),
          87i32 as (u16),
          1111i32 as (u16),
          599i32 as (u16),
          1623i32 as (u16),
          343i32 as (u16),
          1367i32 as (u16),
          855i32 as (u16),
          1879i32 as (u16),
          215i32 as (u16),
          1239i32 as (u16),
          727i32 as (u16),
          1751i32 as (u16),
          471i32 as (u16),
          1495i32 as (u16),
          983i32 as (u16),
          2007i32 as (u16),
          55i32 as (u16),
          1079i32 as (u16),
          567i32 as (u16),
          1591i32 as (u16),
          311i32 as (u16),
          1335i32 as (u16),
          823i32 as (u16),
          1847i32 as (u16),
          183i32 as (u16),
          1207i32 as (u16),
          695i32 as (u16),
          1719i32 as (u16),
          439i32 as (u16),
          1463i32 as (u16),
          951i32 as (u16),
          1975i32 as (u16),
          119i32 as (u16),
          1143i32 as (u16),
          631i32 as (u16),
          1655i32 as (u16),
          375i32 as (u16),
          1399i32 as (u16),
          887i32 as (u16),
          1911i32 as (u16),
          247i32 as (u16),
          1271i32 as (u16),
          759i32 as (u16),
          1783i32 as (u16),
          503i32 as (u16),
          1527i32 as (u16),
          1015i32 as (u16),
          2039i32 as (u16),
          15i32 as (u16),
          1039i32 as (u16),
          527i32 as (u16),
          1551i32 as (u16),
          271i32 as (u16),
          1295i32 as (u16),
          783i32 as (u16),
          1807i32 as (u16),
          143i32 as (u16),
          1167i32 as (u16),
          655i32 as (u16),
          1679i32 as (u16),
          399i32 as (u16),
          1423i32 as (u16),
          911i32 as (u16),
          1935i32 as (u16),
          79i32 as (u16),
          1103i32 as (u16),
          591i32 as (u16),
          1615i32 as (u16),
          335i32 as (u16),
          1359i32 as (u16),
          847i32 as (u16),
          1871i32 as (u16),
          207i32 as (u16),
          1231i32 as (u16),
          719i32 as (u16),
          1743i32 as (u16),
          463i32 as (u16),
          1487i32 as (u16),
          975i32 as (u16),
          1999i32 as (u16),
          47i32 as (u16),
          1071i32 as (u16),
          559i32 as (u16),
          1583i32 as (u16),
          303i32 as (u16),
          1327i32 as (u16),
          815i32 as (u16),
          1839i32 as (u16),
          175i32 as (u16),
          1199i32 as (u16),
          687i32 as (u16),
          1711i32 as (u16),
          431i32 as (u16),
          1455i32 as (u16),
          943i32 as (u16),
          1967i32 as (u16),
          111i32 as (u16),
          1135i32 as (u16),
          623i32 as (u16),
          1647i32 as (u16),
          367i32 as (u16),
          1391i32 as (u16),
          879i32 as (u16),
          1903i32 as (u16),
          239i32 as (u16),
          1263i32 as (u16),
          751i32 as (u16),
          1775i32 as (u16),
          495i32 as (u16),
          1519i32 as (u16),
          1007i32 as (u16),
          2031i32 as (u16),
          31i32 as (u16),
          1055i32 as (u16),
          543i32 as (u16),
          1567i32 as (u16),
          287i32 as (u16),
          1311i32 as (u16),
          799i32 as (u16),
          1823i32 as (u16),
          159i32 as (u16),
          1183i32 as (u16),
          671i32 as (u16),
          1695i32 as (u16),
          415i32 as (u16),
          1439i32 as (u16),
          927i32 as (u16),
          1951i32 as (u16),
          95i32 as (u16),
          1119i32 as (u16),
          607i32 as (u16),
          1631i32 as (u16),
          351i32 as (u16),
          1375i32 as (u16),
          863i32 as (u16),
          1887i32 as (u16),
          223i32 as (u16),
          1247i32 as (u16),
          735i32 as (u16),
          1759i32 as (u16),
          479i32 as (u16),
          1503i32 as (u16),
          991i32 as (u16),
          2015i32 as (u16),
          63i32 as (u16),
          1087i32 as (u16),
          575i32 as (u16),
          1599i32 as (u16),
          319i32 as (u16),
          1343i32 as (u16),
          831i32 as (u16),
          1855i32 as (u16),
          191i32 as (u16),
          1215i32 as (u16),
          703i32 as (u16),
          1727i32 as (u16),
          447i32 as (u16),
          1471i32 as (u16),
          959i32 as (u16),
          1983i32 as (u16),
          127i32 as (u16),
          1151i32 as (u16),
          639i32 as (u16),
          1663i32 as (u16),
          383i32 as (u16),
          1407i32 as (u16),
          895i32 as (u16),
          1919i32 as (u16),
          255i32 as (u16),
          1279i32 as (u16),
          767i32 as (u16),
          1791i32 as (u16),
          511i32 as (u16),
          1535i32 as (u16),
          1023i32 as (u16),
          2047i32 as (u16)
      ];

static mut kStaticDistanceCodeBits
    : [u16; 64]
    = [   0i32 as (u16),
          32i32 as (u16),
          16i32 as (u16),
          48i32 as (u16),
          8i32 as (u16),
          40i32 as (u16),
          24i32 as (u16),
          56i32 as (u16),
          4i32 as (u16),
          36i32 as (u16),
          20i32 as (u16),
          52i32 as (u16),
          12i32 as (u16),
          44i32 as (u16),
          28i32 as (u16),
          60i32 as (u16),
          2i32 as (u16),
          34i32 as (u16),
          18i32 as (u16),
          50i32 as (u16),
          10i32 as (u16),
          42i32 as (u16),
          26i32 as (u16),
          58i32 as (u16),
          6i32 as (u16),
          38i32 as (u16),
          22i32 as (u16),
          54i32 as (u16),
          14i32 as (u16),
          46i32 as (u16),
          30i32 as (u16),
          62i32 as (u16),
          1i32 as (u16),
          33i32 as (u16),
          17i32 as (u16),
          49i32 as (u16),
          9i32 as (u16),
          41i32 as (u16),
          25i32 as (u16),
          57i32 as (u16),
          5i32 as (u16),
          37i32 as (u16),
          21i32 as (u16),
          53i32 as (u16),
          13i32 as (u16),
          45i32 as (u16),
          29i32 as (u16),
          61i32 as (u16),
          3i32 as (u16),
          35i32 as (u16),
          19i32 as (u16),
          51i32 as (u16),
          11i32 as (u16),
          43i32 as (u16),
          27i32 as (u16),
          59i32 as (u16),
          7i32 as (u16),
          39i32 as (u16),
          23i32 as (u16),
          55i32 as (u16),
          15i32 as (u16),
          47i32 as (u16),
          31i32 as (u16),
          63i32 as (u16)
      ];

#[derive(Clone, Copy)]
#[repr(C)]
pub struct PrefixCodeRange {
    pub offset : u32,
    pub nbits : u32,
}

static mut kBlockLengthPrefixCode
    : [PrefixCodeRange; 26]
    = [   PrefixCodeRange {
              offset: 1i32 as (u32),
              nbits: 2i32 as (u32)
          },
          PrefixCodeRange { offset: 5i32 as (u32), nbits: 2i32 as (u32) },
          PrefixCodeRange { offset: 9i32 as (u32), nbits: 2i32 as (u32) },
          PrefixCodeRange { offset: 13i32 as (u32), nbits: 2i32 as (u32) },
          PrefixCodeRange { offset: 17i32 as (u32), nbits: 3i32 as (u32) },
          PrefixCodeRange { offset: 25i32 as (u32), nbits: 3i32 as (u32) },
          PrefixCodeRange { offset: 33i32 as (u32), nbits: 3i32 as (u32) },
          PrefixCodeRange { offset: 41i32 as (u32), nbits: 3i32 as (u32) },
          PrefixCodeRange { offset: 49i32 as (u32), nbits: 4i32 as (u32) },
          PrefixCodeRange { offset: 65i32 as (u32), nbits: 4i32 as (u32) },
          PrefixCodeRange { offset: 81i32 as (u32), nbits: 4i32 as (u32) },
          PrefixCodeRange { offset: 97i32 as (u32), nbits: 4i32 as (u32) },
          PrefixCodeRange { offset: 113i32 as (u32), nbits: 5i32 as (u32) },
          PrefixCodeRange { offset: 145i32 as (u32), nbits: 5i32 as (u32) },
          PrefixCodeRange { offset: 177i32 as (u32), nbits: 5i32 as (u32) },
          PrefixCodeRange { offset: 209i32 as (u32), nbits: 5i32 as (u32) },
          PrefixCodeRange { offset: 241i32 as (u32), nbits: 6i32 as (u32) },
          PrefixCodeRange { offset: 305i32 as (u32), nbits: 6i32 as (u32) },
          PrefixCodeRange { offset: 369i32 as (u32), nbits: 7i32 as (u32) },
          PrefixCodeRange { offset: 497i32 as (u32), nbits: 8i32 as (u32) },
          PrefixCodeRange { offset: 753i32 as (u32), nbits: 9i32 as (u32) },
          PrefixCodeRange {
              offset: 1265i32 as (u32),
              nbits: 10i32 as (u32)
          },
          PrefixCodeRange {
              offset: 2289i32 as (u32),
              nbits: 11i32 as (u32)
          },
          PrefixCodeRange {
              offset: 4337i32 as (u32),
              nbits: 12i32 as (u32)
          },
          PrefixCodeRange {
              offset: 8433i32 as (u32),
              nbits: 13i32 as (u32)
          },
          PrefixCodeRange {
              offset: 16625i32 as (u32),
              nbits: 24i32 as (u32)
          }
      ];

#[derive(Clone, Copy)]
#[repr(C)]
pub struct HuffmanTree {
    pub total_count_ : u32,
    pub index_left_ : i16,
    pub index_right_or_value_ : i16,
}

unsafe extern fn BROTLI_UNALIGNED_STORE64(
    mut p : *mut ::std::os::raw::c_void, mut v : usize
) {
    memcpy(
        p,
        &mut v as (*mut usize) as (*const ::std::os::raw::c_void),
        ::std::mem::size_of::<usize>()
    );
}

unsafe extern fn BrotliWriteBits(
    mut n_bits : usize,
    mut bits : usize,
    mut pos : *mut usize,
    mut array : *mut u8
) {
    let mut p
        : *mut u8
        = &mut *array.offset((*pos >> 3i32) as (isize)) as (*mut u8);
    let mut v : usize = *p as (usize);
    0i32;
    0i32;
    v = v | bits << (*pos & 7i32 as (usize));
    BROTLI_UNALIGNED_STORE64(p as (*mut ::std::os::raw::c_void),v);
    *pos = (*pos).wrapping_add(n_bits);
}

unsafe extern fn BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask(
    num_codes : i32,
    mut code_length_bitdepth : *const u8,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    static mut kStorageOrder
        : [u8; 18]
        = [   1i32 as (u8),
              2i32 as (u8),
              3i32 as (u8),
              4i32 as (u8),
              0i32 as (u8),
              5i32 as (u8),
              17i32 as (u8),
              6i32 as (u8),
              16i32 as (u8),
              7i32 as (u8),
              8i32 as (u8),
              9i32 as (u8),
              10i32 as (u8),
              11i32 as (u8),
              12i32 as (u8),
              13i32 as (u8),
              14i32 as (u8),
              15i32 as (u8)
          ];
    static mut kHuffmanBitLengthHuffmanCodeSymbols
        : [u8; 6]
        = [   0i32 as (u8),
              7i32 as (u8),
              3i32 as (u8),
              2i32 as (u8),
              1i32 as (u8),
              15i32 as (u8)
          ];
    static mut kHuffmanBitLengthHuffmanCodeBitLengths
        : [u8; 6]
        = [   2i32 as (u8),
              4i32 as (u8),
              3i32 as (u8),
              2i32 as (u8),
              2i32 as (u8),
              4i32 as (u8)
          ];
    let mut skip_some : usize = 0i32 as (usize);
    let mut codes_to_store : usize = 18i32 as (usize);
    if num_codes > 1i32 {
        'break5: while codes_to_store > 0i32 as (usize) {
            {
                if *code_length_bitdepth.offset(
                        kStorageOrder[
                            codes_to_store.wrapping_sub(1i32 as (usize))
                        ] as (isize)
                    ) as (i32) != 0i32 {
                    if 1337i32 != 0 {
                        break 'break5;
                    }
                }
            }
            codes_to_store = codes_to_store.wrapping_sub(1 as (usize));
        }
    }
    if *code_length_bitdepth.offset(
            kStorageOrder[0i32 as (usize)] as (isize)
        ) as (i32) == 0i32 && (*code_length_bitdepth.offset(
                                    kStorageOrder[1i32 as (usize)] as (isize)
                                ) as (i32) == 0i32) {
        skip_some = 2i32 as (usize);
        if *code_length_bitdepth.offset(
                kStorageOrder[2i32 as (usize)] as (isize)
            ) as (i32) == 0i32 {
            skip_some = 3i32 as (usize);
        }
    }
    BrotliWriteBits(2i32 as (usize),skip_some,storage_ix,storage);
    {
        let mut i : usize;
        i = skip_some;
        while i < codes_to_store {
            {
                let mut l
                    : usize
                    = *code_length_bitdepth.offset(
                           kStorageOrder[i] as (isize)
                       ) as (usize);
                BrotliWriteBits(
                    kHuffmanBitLengthHuffmanCodeBitLengths[l] as (usize),
                    kHuffmanBitLengthHuffmanCodeSymbols[l] as (usize),
                    storage_ix,
                    storage
                );
            }
            i = i.wrapping_add(1 as (usize));
        }
    }
}

unsafe extern fn BrotliStoreHuffmanTreeToBitMask(
    huffman_tree_size : usize,
    mut huffman_tree : *const u8,
    mut huffman_tree_extra_bits : *const u8,
    mut code_length_bitdepth : *const u8,
    mut code_length_bitdepth_symbols : *const u16,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    let mut i : usize;
    i = 0i32 as (usize);
    while i < huffman_tree_size {
        {
            let mut ix : usize = *huffman_tree.offset(i as (isize)) as (usize);
            BrotliWriteBits(
                *code_length_bitdepth.offset(ix as (isize)) as (usize),
                *code_length_bitdepth_symbols.offset(ix as (isize)) as (usize),
                storage_ix,
                storage
            );
            if ix == 16i32 as (usize) {
                BrotliWriteBits(
                    2i32 as (usize),
                    *huffman_tree_extra_bits.offset(i as (isize)) as (usize),
                    storage_ix,
                    storage
                );
            } else if ix == 17i32 as (usize) {
                BrotliWriteBits(
                    3i32 as (usize),
                    *huffman_tree_extra_bits.offset(i as (isize)) as (usize),
                    storage_ix,
                    storage
                );
            }
        }
        i = i.wrapping_add(1 as (usize));
    }
}

#[no_mangle]
pub unsafe extern fn BrotliStoreHuffmanTree(
    mut depths : *const u8,
    mut num : usize,
    mut tree : *mut HuffmanTree,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    let mut huffman_tree : [u8; 704];
    let mut huffman_tree_extra_bits : [u8; 704];
    let mut huffman_tree_size : usize = 0i32 as (usize);
    let mut code_length_bitdepth
        : [u8; 18]
        = [   0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8)
          ];
    let mut code_length_bitdepth_symbols : [u16; 18];
    let mut huffman_tree_histogram
        : [u32; 18]
        = [   0i32 as (u32),
              0i32 as (u32),
              0i32 as (u32),
              0i32 as (u32),
              0i32 as (u32),
              0i32 as (u32),
              0i32 as (u32),
              0i32 as (u32),
              0i32 as (u32),
              0i32 as (u32),
              0i32 as (u32),
              0i32 as (u32),
              0i32 as (u32),
              0i32 as (u32),
              0i32 as (u32),
              0i32 as (u32),
              0i32 as (u32),
              0i32 as (u32)
          ];
    let mut i : usize;
    let mut num_codes : i32 = 0i32;
    let mut code : usize = 0i32 as (usize);
    0i32;
    BrotliWriteHuffmanTree(
        depths,
        num,
        &mut huffman_tree_size as (*mut usize),
        huffman_tree.as_mut_ptr(),
        huffman_tree_extra_bits.as_mut_ptr()
    );
    i = 0i32 as (usize);
    while i < huffman_tree_size {
        {
            let _rhs = 1;
            let _lhs = &mut huffman_tree_histogram[huffman_tree[i] as (usize)];
            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
        }
        i = i.wrapping_add(1 as (usize));
    }
    i = 0i32 as (usize);
    'break3: while i < 18i32 as (usize) {
        {
            if huffman_tree_histogram[i] != 0 {
                if num_codes == 0i32 {
                    code = i;
                    num_codes = 1i32;
                } else if num_codes == 1i32 {
                    num_codes = 2i32;
                    {
                        if 1337i32 != 0 {
                            break 'break3;
                        }
                    }
                }
            }
        }
        i = i.wrapping_add(1 as (usize));
    }
    BrotliCreateHuffmanTree(
        huffman_tree_histogram.as_mut_ptr() as (*const u32),
        18i32 as (usize),
        5i32,
        tree,
        code_length_bitdepth.as_mut_ptr()
    );
    BrotliConvertBitDepthsToSymbols(
        code_length_bitdepth.as_mut_ptr() as (*const u8),
        18i32 as (usize),
        code_length_bitdepth_symbols.as_mut_ptr()
    );
    BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask(
        num_codes,
        code_length_bitdepth.as_mut_ptr() as (*const u8),
        storage_ix,
        storage
    );
    if num_codes == 1i32 {
        code_length_bitdepth[code] = 0i32 as (u8);
    }
    BrotliStoreHuffmanTreeToBitMask(
        huffman_tree_size,
        huffman_tree.as_mut_ptr() as (*const u8),
        huffman_tree_extra_bits.as_mut_ptr() as (*const u8),
        code_length_bitdepth.as_mut_ptr() as (*const u8),
        code_length_bitdepth_symbols.as_mut_ptr() as (*const u16),
        storage_ix,
        storage
    );
}

#[derive(Clone, Copy)]
#[repr(C)]
pub struct MemoryManager {
    pub alloc_func : unsafe extern fn(*mut ::std::os::raw::c_void, usize) -> *mut ::std::os::raw::c_void,
    pub free_func : unsafe extern fn(*mut ::std::os::raw::c_void, *mut ::std::os::raw::c_void),
    pub opaque : *mut ::std::os::raw::c_void,
}

unsafe extern fn InitHuffmanTree(
    mut self : *mut HuffmanTree,
    mut count : u32,
    mut left : i16,
    mut right : i16
) {
    (*self).total_count_ = count;
    (*self).index_left_ = left;
    (*self).index_right_or_value_ = right;
}

unsafe extern fn SortHuffmanTreeItems(
    mut items : *mut HuffmanTree,
    n : usize,
    mut
    comparator
    :
    unsafe extern fn(*const HuffmanTree, *const HuffmanTree) -> i32
) {
    static mut gaps
        : [usize; 6]
        = [   132i32 as (usize),
              57i32 as (usize),
              23i32 as (usize),
              10i32 as (usize),
              4i32 as (usize),
              1i32 as (usize)
          ];
    if n < 13i32 as (usize) {
        let mut i : usize;
        i = 1i32 as (usize);
        while i < n {
            {
                let mut tmp : HuffmanTree = *items.offset(i as (isize));
                let mut k : usize = i;
                let mut j : usize = i.wrapping_sub(1i32 as (usize));
                while comparator(
                          &mut tmp as (*mut HuffmanTree) as (*const HuffmanTree),
                          &mut *items.offset(
                                    j as (isize)
                                ) as (*mut HuffmanTree) as (*const HuffmanTree)
                      ) != 0 {
                    *items.offset(k as (isize)) = *items.offset(j as (isize));
                    k = j;
                    if {
                           let _old = j;
                           j = j.wrapping_sub(1 as (usize));
                           _old
                       } == 0 {
                        if 1337i32 != 0 {
                            break;
                        }
                    }
                }
                *items.offset(k as (isize)) = tmp;
            }
            i = i.wrapping_add(1 as (usize));
        }
    } else {
        let mut g : i32 = if n < 57i32 as (usize) { 2i32 } else { 0i32 };
        while g < 6i32 {
            {
                let mut gap : usize = gaps[g as (usize)];
                let mut i : usize;
                i = gap;
                while i < n {
                    {
                        let mut j : usize = i;
                        let mut tmp : HuffmanTree = *items.offset(i as (isize));
                        while j >= gap && (comparator(
                                               &mut tmp as (*mut HuffmanTree) as (*const HuffmanTree),
                                               &mut *items.offset(
                                                         j.wrapping_sub(gap) as (isize)
                                                     ) as (*mut HuffmanTree) as (*const HuffmanTree)
                                           ) != 0) {
                            {
                                *items.offset(j as (isize)) = *items.offset(
                                                                   j.wrapping_sub(gap) as (isize)
                                                               );
                            }
                            j = j.wrapping_sub(gap);
                        }
                        *items.offset(j as (isize)) = tmp;
                    }
                    i = i.wrapping_add(1 as (usize));
                }
            }
            g = g + 1;
        }
    }
}

unsafe extern fn SortHuffmanTree(
    mut v0 : *const HuffmanTree, mut v1 : *const HuffmanTree
) -> i32 {
    if !!((*v0).total_count_ < (*v1).total_count_) {
        1i32
    } else {
        0i32
    }
}

unsafe extern fn StoreStaticCodeLengthCode(
    mut storage_ix : *mut usize, mut storage : *mut u8
) {
    BrotliWriteBits(
        40i32 as (usize),
        0xffu32 as (usize) << 32i32 | 0x55555554u32 as (usize),
        storage_ix,
        storage
    );
}

#[no_mangle]
pub unsafe extern fn BrotliBuildAndStoreHuffmanTreeFast(
    mut m : *mut MemoryManager,
    mut histogram : *const u32,
    histogram_total : usize,
    max_bits : usize,
    mut depth : *mut u8,
    mut bits : *mut u16,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    let mut count : usize = 0i32 as (usize);
    let mut symbols
        : [usize; 4]
        = [   0i32 as (usize),
              0i32 as (usize),
              0i32 as (usize),
              0i32 as (usize)
          ];
    let mut length : usize = 0i32 as (usize);
    let mut total : usize = histogram_total;
    while total != 0i32 as (usize) {
        if *histogram.offset(length as (isize)) != 0 {
            if count < 4i32 as (usize) {
                symbols[count] = length;
            }
            count = count.wrapping_add(1 as (usize));
            total = total.wrapping_sub(
                        *histogram.offset(length as (isize)) as (usize)
                    );
        }
        length = length.wrapping_add(1 as (usize));
    }
    if count <= 1i32 as (usize) {
        BrotliWriteBits(
            4i32 as (usize),
            1i32 as (usize),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            max_bits,
            symbols[0i32 as (usize)],
            storage_ix,
            storage
        );
        *depth.offset(symbols[0i32 as (usize)] as (isize)) = 0i32 as (u8);
        *bits.offset(symbols[0i32 as (usize)] as (isize)) = 0i32 as (u16);
        return;
    }
    memset(
        depth as (*mut ::std::os::raw::c_void),
        0i32,
        length.wrapping_mul(::std::mem::size_of::<u8>())
    );
    {
        let max_tree_size
            : usize
            = (2i32 as (usize)).wrapping_mul(length).wrapping_add(
                  1i32 as (usize)
              );
        let mut tree
            : *mut HuffmanTree
            = if max_tree_size != 0 {
                  BrotliAllocate(
                      m,
                      max_tree_size.wrapping_mul(::std::mem::size_of::<HuffmanTree>())
                  ) as (*mut HuffmanTree)
              } else {
                  0i32 as (*mut ::std::os::raw::c_void) as (*mut HuffmanTree)
              };
        let mut count_limit : u32;
        if !(0i32 == 0) {
            return;
        }
        count_limit = 1i32 as (u32);
        'break11: loop {
            {
                let mut node_index : u32 = 0i32 as (u32);
                let mut l : usize;
                l = length;
                while l != 0i32 as (usize) {
                    l = l.wrapping_sub(1 as (usize));
                    if *histogram.offset(l as (isize)) != 0 {
                        if *histogram.offset(l as (isize)) >= count_limit {
                            InitHuffmanTree(
                                &mut *tree.offset(node_index as (isize)) as (*mut HuffmanTree),
                                *histogram.offset(l as (isize)),
                                -1i32 as (i16),
                                l as (i16)
                            );
                        } else {
                            InitHuffmanTree(
                                &mut *tree.offset(node_index as (isize)) as (*mut HuffmanTree),
                                count_limit,
                                -1i32 as (i16),
                                l as (i16)
                            );
                        }
                        node_index = node_index.wrapping_add(1 as (u32));
                    }
                }
                {
                    let n : i32 = node_index as (i32);
                    let mut sentinel : HuffmanTree;
                    let mut i : i32 = 0i32;
                    let mut j : i32 = n + 1i32;
                    let mut k : i32;
                    SortHuffmanTreeItems(tree,n as (usize),SortHuffmanTree);
                    InitHuffmanTree(
                        &mut sentinel as (*mut HuffmanTree),
                        !(0i32 as (u32)),
                        -1i32 as (i16),
                        -1i32 as (i16)
                    );
                    *tree.offset(
                         node_index.wrapping_add(1i32 as (u32)) as (isize)
                     ) = sentinel;
                    *tree.offset(node_index as (isize)) = sentinel;
                    node_index = node_index.wrapping_add(2i32 as (u32));
                    k = n - 1i32;
                    while k > 0i32 {
                        {
                            let mut left : i32;
                            let mut right : i32;
                            if (*tree.offset(i as (isize))).total_count_ <= (*tree.offset(
                                                                                  j as (isize)
                                                                              )).total_count_ {
                                left = i;
                                i = i + 1;
                            } else {
                                left = j;
                                j = j + 1;
                            }
                            if (*tree.offset(i as (isize))).total_count_ <= (*tree.offset(
                                                                                  j as (isize)
                                                                              )).total_count_ {
                                right = i;
                                i = i + 1;
                            } else {
                                right = j;
                                j = j + 1;
                            }
                            (*tree.offset(
                                  node_index.wrapping_sub(1i32 as (u32)) as (isize)
                              )).total_count_ = (*tree.offset(
                                                      left as (isize)
                                                  )).total_count_.wrapping_add(
                                                    (*tree.offset(right as (isize))).total_count_
                                                );
                            (*tree.offset(
                                  node_index.wrapping_sub(1i32 as (u32)) as (isize)
                              )).index_left_ = left as (i16);
                            (*tree.offset(
                                  node_index.wrapping_sub(1i32 as (u32)) as (isize)
                              )).index_right_or_value_ = right as (i16);
                            *tree.offset(node_index as (isize)) = sentinel;
                            node_index = node_index.wrapping_add(1i32 as (u32));
                        }
                        k = k - 1;
                    }
                    if BrotliSetDepth(2i32 * n - 1i32,tree,depth,14i32) != 0 {
                        if 1337i32 != 0 {
                            break 'break11;
                        }
                    }
                }
            }
            count_limit = count_limit.wrapping_mul(2i32 as (u32));
        }
        {
            BrotliFree(m,tree as (*mut ::std::os::raw::c_void));
            tree = 0i32 as (*mut ::std::os::raw::c_void) as (*mut HuffmanTree);
        }
    }
    BrotliConvertBitDepthsToSymbols(depth as (*const u8),length,bits);
    if count <= 4i32 as (usize) {
        let mut i : usize;
        BrotliWriteBits(
            2i32 as (usize),
            1i32 as (usize),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            2i32 as (usize),
            count.wrapping_sub(1i32 as (usize)),
            storage_ix,
            storage
        );
        i = 0i32 as (usize);
        while i < count {
            {
                let mut j : usize;
                j = i.wrapping_add(1i32 as (usize));
                while j < count {
                    {
                        if *depth.offset(symbols[j] as (isize)) as (i32) < *depth.offset(
                                                                                symbols[
                                                                                    i
                                                                                ] as (isize)
                                                                            ) as (i32) {
                            let mut __brotli_swap_tmp : usize = symbols[j];
                            symbols[j] = symbols[i];
                            symbols[i] = __brotli_swap_tmp;
                        }
                    }
                    j = j.wrapping_add(1 as (usize));
                }
            }
            i = i.wrapping_add(1 as (usize));
        }
        if count == 2i32 as (usize) {
            BrotliWriteBits(
                max_bits,
                symbols[0i32 as (usize)],
                storage_ix,
                storage
            );
            BrotliWriteBits(
                max_bits,
                symbols[1i32 as (usize)],
                storage_ix,
                storage
            );
        } else if count == 3i32 as (usize) {
            BrotliWriteBits(
                max_bits,
                symbols[0i32 as (usize)],
                storage_ix,
                storage
            );
            BrotliWriteBits(
                max_bits,
                symbols[1i32 as (usize)],
                storage_ix,
                storage
            );
            BrotliWriteBits(
                max_bits,
                symbols[2i32 as (usize)],
                storage_ix,
                storage
            );
        } else {
            BrotliWriteBits(
                max_bits,
                symbols[0i32 as (usize)],
                storage_ix,
                storage
            );
            BrotliWriteBits(
                max_bits,
                symbols[1i32 as (usize)],
                storage_ix,
                storage
            );
            BrotliWriteBits(
                max_bits,
                symbols[2i32 as (usize)],
                storage_ix,
                storage
            );
            BrotliWriteBits(
                max_bits,
                symbols[3i32 as (usize)],
                storage_ix,
                storage
            );
            BrotliWriteBits(
                1i32 as (usize),
                if *depth.offset(
                        symbols[0i32 as (usize)] as (isize)
                    ) as (i32) == 1i32 {
                    1i32
                } else {
                    0i32
                } as (usize),
                storage_ix,
                storage
            );
        }
    } else {
        let mut previous_value : u8 = 8i32 as (u8);
        let mut i : usize;
        StoreStaticCodeLengthCode(storage_ix,storage);
        i = 0i32 as (usize);
        while i < length {
            let value : u8 = *depth.offset(i as (isize));
            let mut reps : usize = 1i32 as (usize);
            let mut k : usize;
            k = i.wrapping_add(1i32 as (usize));
            while k < length && (*depth.offset(
                                      k as (isize)
                                  ) as (i32) == value as (i32)) {
                {
                    reps = reps.wrapping_add(1 as (usize));
                }
                k = k.wrapping_add(1 as (usize));
            }
            i = i.wrapping_add(reps);
            if value as (i32) == 0i32 {
                BrotliWriteBits(
                    kZeroRepsDepth[reps] as (usize),
                    kZeroRepsBits[reps],
                    storage_ix,
                    storage
                );
            } else {
                if previous_value as (i32) != value as (i32) {
                    BrotliWriteBits(
                        kCodeLengthDepth[value as (usize)] as (usize),
                        kCodeLengthBits[value as (usize)] as (usize),
                        storage_ix,
                        storage
                    );
                    reps = reps.wrapping_sub(1 as (usize));
                }
                if reps < 3i32 as (usize) {
                    while reps != 0i32 as (usize) {
                        reps = reps.wrapping_sub(1 as (usize));
                        BrotliWriteBits(
                            kCodeLengthDepth[value as (usize)] as (usize),
                            kCodeLengthBits[value as (usize)] as (usize),
                            storage_ix,
                            storage
                        );
                    }
                } else {
                    reps = reps.wrapping_sub(3i32 as (usize));
                    BrotliWriteBits(
                        kNonZeroRepsDepth[reps] as (usize),
                        kNonZeroRepsBits[reps],
                        storage_ix,
                        storage
                    );
                }
                previous_value = value;
            }
        }
    }
}

#[derive(Clone, Copy)]
#[repr(i32)]
pub enum ContextType {
    CONTEXT_LSB6 = 0i32,
    CONTEXT_MSB6 = 1i32,
    CONTEXT_UTF8 = 2i32,
    CONTEXT_SIGNED = 3i32,
}

#[derive(Clone, Copy)]
#[repr(C)]
pub struct Command {
    pub insert_len_ : u32,
    pub copy_len_ : u32,
    pub dist_extra_ : u32,
    pub cmd_prefix_ : u16,
    pub dist_prefix_ : u16,
}

#[derive(Clone, Copy)]
#[repr(C)]
pub struct BlockSplit {
    pub num_types : usize,
    pub num_blocks : usize,
    pub types : *mut u8,
    pub lengths : *mut u32,
    pub types_alloc_size : usize,
    pub lengths_alloc_size : usize,
}

#[derive(Clone, Copy)]
#[repr(C)]
pub struct HistogramLiteral {
    pub data_ : [u32; 256],
    pub total_count_ : usize,
    pub bit_cost_ : f64,
}

#[derive(Clone, Copy)]
#[repr(C)]
pub struct HistogramCommand {
    pub data_ : [u32; 704],
    pub total_count_ : usize,
    pub bit_cost_ : f64,
}

#[derive(Clone, Copy)]
#[repr(C)]
pub struct HistogramDistance {
    pub data_ : [u32; 520],
    pub total_count_ : usize,
    pub bit_cost_ : f64,
}

#[derive(Clone, Copy)]
#[repr(C)]
pub struct MetaBlockSplit {
    pub literal_split : BlockSplit,
    pub command_split : BlockSplit,
    pub distance_split : BlockSplit,
    pub literal_context_map : *mut u32,
    pub literal_context_map_size : usize,
    pub distance_context_map : *mut u32,
    pub distance_context_map_size : usize,
    pub literal_histograms : *mut HistogramLiteral,
    pub literal_histograms_size : usize,
    pub command_histograms : *mut HistogramCommand,
    pub command_histograms_size : usize,
    pub distance_histograms : *mut HistogramDistance,
    pub distance_histograms_size : usize,
}

#[derive(Clone, Copy)]
#[repr(C)]
pub struct BlockTypeCodeCalculator {
    pub last_type : usize,
    pub second_last_type : usize,
}

#[derive(Clone, Copy)]
#[repr(C)]
pub struct BlockSplitCode {
    pub type_code_calculator : BlockTypeCodeCalculator,
    pub type_depths : [u8; 258],
    pub type_bits : [u16; 258],
    pub length_depths : [u8; 26],
    pub length_bits : [u16; 26],
}

#[derive(Clone, Copy)]
#[repr(C)]
pub struct BlockEncoder {
    pub alphabet_size_ : usize,
    pub num_block_types_ : usize,
    pub block_types_ : *const u8,
    pub block_lengths_ : *const u32,
    pub num_blocks_ : usize,
    pub block_split_code_ : BlockSplitCode,
    pub block_ix_ : usize,
    pub block_len_ : usize,
    pub entropy_ix_ : usize,
    pub depths_ : *mut u8,
    pub bits_ : *mut u16,
}

unsafe extern fn Log2FloorNonZero(mut n : usize) -> u32 {
    let mut result : u32 = 0i32 as (u32);
    while {
              n = n >> 1i32;
              n
          } != 0 {
        result = result.wrapping_add(1 as (u32));
    }
    result
}

unsafe extern fn BrotliEncodeMlen(
    mut length : usize,
    mut bits : *mut usize,
    mut numbits : *mut usize,
    mut nibblesbits : *mut usize
) {
    let mut lg
        : usize
        = (if length == 1i32 as (usize) {
               1i32 as (u32)
           } else {
               Log2FloorNonZero(
                   length.wrapping_sub(1i32 as (usize)) as (u32) as (usize)
               ).wrapping_add(
                   1i32 as (u32)
               )
           }) as (usize);
    let mut mnibbles
        : usize
        = (if lg < 16i32 as (usize) {
               16i32 as (usize)
           } else {
               lg.wrapping_add(3i32 as (usize))
           }).wrapping_div(
              4i32 as (usize)
          );
    0i32;
    0i32;
    0i32;
    *nibblesbits = mnibbles.wrapping_sub(4i32 as (usize));
    *numbits = mnibbles.wrapping_mul(4i32 as (usize));
    *bits = length.wrapping_sub(1i32 as (usize));
}

unsafe extern fn StoreCompressedMetaBlockHeader(
    mut is_final_block : i32,
    mut length : usize,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    let mut lenbits : usize;
    let mut nlenbits : usize;
    let mut nibblesbits : usize;
    BrotliWriteBits(
        1i32 as (usize),
        is_final_block as (usize),
        storage_ix,
        storage
    );
    if is_final_block != 0 {
        BrotliWriteBits(
            1i32 as (usize),
            0i32 as (usize),
            storage_ix,
            storage
        );
    }
    BrotliEncodeMlen(
        length,
        &mut lenbits as (*mut usize),
        &mut nlenbits as (*mut usize),
        &mut nibblesbits as (*mut usize)
    );
    BrotliWriteBits(2i32 as (usize),nibblesbits,storage_ix,storage);
    BrotliWriteBits(nlenbits,lenbits,storage_ix,storage);
    if is_final_block == 0 {
        BrotliWriteBits(
            1i32 as (usize),
            0i32 as (usize),
            storage_ix,
            storage
        );
    }
}

unsafe extern fn InitBlockTypeCodeCalculator(
    mut self : *mut BlockTypeCodeCalculator
) {
    (*self).last_type = 1i32 as (usize);
    (*self).second_last_type = 0i32 as (usize);
}

unsafe extern fn InitBlockEncoder(
    mut self : *mut BlockEncoder,
    mut alphabet_size : usize,
    mut num_block_types : usize,
    mut block_types : *const u8,
    mut block_lengths : *const u32,
    num_blocks : usize
) {
    (*self).alphabet_size_ = alphabet_size;
    (*self).num_block_types_ = num_block_types;
    (*self).block_types_ = block_types;
    (*self).block_lengths_ = block_lengths;
    (*self).num_blocks_ = num_blocks;
    InitBlockTypeCodeCalculator(
        &mut (*self).block_split_code_.type_code_calculator as (*mut BlockTypeCodeCalculator)
    );
    (*self).block_ix_ = 0i32 as (usize);
    (*self).block_len_ = if num_blocks == 0i32 as (usize) {
                             0i32 as (u32)
                         } else {
                             *block_lengths.offset(0i32 as (isize))
                         } as (usize);
    (*self).entropy_ix_ = 0i32 as (usize);
    (*self).depths_ = 0i32 as (*mut u8);
    (*self).bits_ = 0i32 as (*mut u16);
}

unsafe extern fn NextBlockTypeCode(
    mut calculator : *mut BlockTypeCodeCalculator, mut type_ : u8
) -> usize {
    let mut type_code
        : usize
        = (if type_ as (usize) == (*calculator).last_type.wrapping_add(
                                      1i32 as (usize)
                                  ) {
               1u32
           } else if type_ as (usize) == (*calculator).second_last_type {
               0u32
           } else {
               (type_ as (u32)).wrapping_add(2u32)
           }) as (usize);
    (*calculator).second_last_type = (*calculator).last_type;
    (*calculator).last_type = type_ as (usize);
    type_code
}

unsafe extern fn BlockLengthPrefixCode(mut len : u32) -> u32 {
    let mut code
        : u32
        = (if len >= 177i32 as (u32) {
               if len >= 753i32 as (u32) { 20i32 } else { 14i32 }
           } else if len >= 41i32 as (u32) {
               7i32
           } else {
               0i32
           }) as (u32);
    while code < (26i32 - 1i32) as (u32) && (len >= kBlockLengthPrefixCode[
                                                        code.wrapping_add(1i32 as (u32)) as (usize)
                                                    ].offset) {
        code = code.wrapping_add(1 as (u32));
    }
    code
}

unsafe extern fn StoreVarLenUint8(
    mut n : usize, mut storage_ix : *mut usize, mut storage : *mut u8
) { if n == 0i32 as (usize) {
        BrotliWriteBits(
            1i32 as (usize),
            0i32 as (usize),
            storage_ix,
            storage
        );
    } else {
        let mut nbits : usize = Log2FloorNonZero(n) as (usize);
        BrotliWriteBits(
            1i32 as (usize),
            1i32 as (usize),
            storage_ix,
            storage
        );
        BrotliWriteBits(3i32 as (usize),nbits,storage_ix,storage);
        BrotliWriteBits(
            nbits,
            n.wrapping_sub(1i32 as (usize) << nbits),
            storage_ix,
            storage
        );
    }
}

unsafe extern fn StoreSimpleHuffmanTree(
    mut depths : *const u8,
    mut symbols : *mut usize,
    mut num_symbols : usize,
    mut max_bits : usize,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    BrotliWriteBits(
        2i32 as (usize),
        1i32 as (usize),
        storage_ix,
        storage
    );
    BrotliWriteBits(
        2i32 as (usize),
        num_symbols.wrapping_sub(1i32 as (usize)),
        storage_ix,
        storage
    );
    {
        let mut i : usize;
        i = 0i32 as (usize);
        while i < num_symbols {
            {
                let mut j : usize;
                j = i.wrapping_add(1i32 as (usize));
                while j < num_symbols {
                    {
                        if *depths.offset(
                                *symbols.offset(j as (isize)) as (isize)
                            ) as (i32) < *depths.offset(
                                              *symbols.offset(i as (isize)) as (isize)
                                          ) as (i32) {
                            let mut __brotli_swap_tmp : usize = *symbols.offset(j as (isize));
                            *symbols.offset(j as (isize)) = *symbols.offset(i as (isize));
                            *symbols.offset(i as (isize)) = __brotli_swap_tmp;
                        }
                    }
                    j = j.wrapping_add(1 as (usize));
                }
            }
            i = i.wrapping_add(1 as (usize));
        }
    }
    if num_symbols == 2i32 as (usize) {
        BrotliWriteBits(
            max_bits,
            *symbols.offset(0i32 as (isize)),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            max_bits,
            *symbols.offset(1i32 as (isize)),
            storage_ix,
            storage
        );
    } else if num_symbols == 3i32 as (usize) {
        BrotliWriteBits(
            max_bits,
            *symbols.offset(0i32 as (isize)),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            max_bits,
            *symbols.offset(1i32 as (isize)),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            max_bits,
            *symbols.offset(2i32 as (isize)),
            storage_ix,
            storage
        );
    } else {
        BrotliWriteBits(
            max_bits,
            *symbols.offset(0i32 as (isize)),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            max_bits,
            *symbols.offset(1i32 as (isize)),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            max_bits,
            *symbols.offset(2i32 as (isize)),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            max_bits,
            *symbols.offset(3i32 as (isize)),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            1i32 as (usize),
            if *depths.offset(
                    *symbols.offset(0i32 as (isize)) as (isize)
                ) as (i32) == 1i32 {
                1i32
            } else {
                0i32
            } as (usize),
            storage_ix,
            storage
        );
    }
}

unsafe extern fn BuildAndStoreHuffmanTree(
    mut histogram : *const u32,
    length : usize,
    mut tree : *mut HuffmanTree,
    mut depth : *mut u8,
    mut bits : *mut u16,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    let mut count : usize = 0i32 as (usize);
    let mut s4
        : [usize; 4]
        = [   0i32 as (usize),
              0i32 as (usize),
              0i32 as (usize),
              0i32 as (usize)
          ];
    let mut i : usize;
    let mut max_bits : usize = 0i32 as (usize);
    i = 0i32 as (usize);
    'break31: while i < length {
        {
            if *histogram.offset(i as (isize)) != 0 {
                if count < 4i32 as (usize) {
                    s4[count] = i;
                } else if count > 4i32 as (usize) {
                    if 1337i32 != 0 {
                        break 'break31;
                    }
                }
                count = count.wrapping_add(1 as (usize));
            }
        }
        i = i.wrapping_add(1 as (usize));
    }
    {
        let mut max_bits_counter
            : usize
            = length.wrapping_sub(1i32 as (usize));
        while max_bits_counter != 0 {
            max_bits_counter = max_bits_counter >> 1i32;
            max_bits = max_bits.wrapping_add(1 as (usize));
        }
    }
    if count <= 1i32 as (usize) {
        BrotliWriteBits(
            4i32 as (usize),
            1i32 as (usize),
            storage_ix,
            storage
        );
        BrotliWriteBits(max_bits,s4[0i32 as (usize)],storage_ix,storage);
        *depth.offset(s4[0i32 as (usize)] as (isize)) = 0i32 as (u8);
        *bits.offset(s4[0i32 as (usize)] as (isize)) = 0i32 as (u16);
        return;
    }
    memset(
        depth as (*mut ::std::os::raw::c_void),
        0i32,
        length.wrapping_mul(::std::mem::size_of::<u8>())
    );
    BrotliCreateHuffmanTree(histogram,length,15i32,tree,depth);
    BrotliConvertBitDepthsToSymbols(depth as (*const u8),length,bits);
    if count <= 4i32 as (usize) {
        StoreSimpleHuffmanTree(
            depth as (*const u8),
            s4.as_mut_ptr(),
            count,
            max_bits,
            storage_ix,
            storage
        );
    } else {
        BrotliStoreHuffmanTree(
            depth as (*const u8),
            length,
            tree,
            storage_ix,
            storage
        );
    }
}

unsafe extern fn GetBlockLengthPrefixCode(
    mut len : u32,
    mut code : *mut usize,
    mut n_extra : *mut u32,
    mut extra : *mut u32
) {
    *code = BlockLengthPrefixCode(len) as (usize);
    *n_extra = kBlockLengthPrefixCode[*code].nbits;
    *extra = len.wrapping_sub(kBlockLengthPrefixCode[*code].offset);
}

unsafe extern fn StoreBlockSwitch(
    mut code : *mut BlockSplitCode,
    block_len : u32,
    block_type : u8,
    mut is_first_block : i32,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    let mut typecode
        : usize
        = NextBlockTypeCode(
              &mut (*code).type_code_calculator as (*mut BlockTypeCodeCalculator),
              block_type
          );
    let mut lencode : usize;
    let mut len_nextra : u32;
    let mut len_extra : u32;
    if is_first_block == 0 {
        BrotliWriteBits(
            (*code).type_depths[typecode] as (usize),
            (*code).type_bits[typecode] as (usize),
            storage_ix,
            storage
        );
    }
    GetBlockLengthPrefixCode(
        block_len,
        &mut lencode as (*mut usize),
        &mut len_nextra as (*mut u32),
        &mut len_extra as (*mut u32)
    );
    BrotliWriteBits(
        (*code).length_depths[lencode] as (usize),
        (*code).length_bits[lencode] as (usize),
        storage_ix,
        storage
    );
    BrotliWriteBits(
        len_nextra as (usize),
        len_extra as (usize),
        storage_ix,
        storage
    );
}

unsafe extern fn BuildAndStoreBlockSplitCode(
    mut types : *const u8,
    mut lengths : *const u32,
    num_blocks : usize,
    num_types : usize,
    mut tree : *mut HuffmanTree,
    mut code : *mut BlockSplitCode,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    let mut type_histo : [u32; 258];
    let mut length_histo : [u32; 26];
    let mut i : usize;
    let mut type_code_calculator : BlockTypeCodeCalculator;
    memset(
        type_histo.as_mut_ptr() as (*mut ::std::os::raw::c_void),
        0i32,
        num_types.wrapping_add(2i32 as (usize)).wrapping_mul(
            ::std::mem::size_of::<u32>()
        )
    );
    memset(
        length_histo.as_mut_ptr() as (*mut ::std::os::raw::c_void),
        0i32,
        ::std::mem::size_of::<[u32; 26]>()
    );
    InitBlockTypeCodeCalculator(
        &mut type_code_calculator as (*mut BlockTypeCodeCalculator)
    );
    i = 0i32 as (usize);
    while i < num_blocks {
        {
            let mut type_code
                : usize
                = NextBlockTypeCode(
                      &mut type_code_calculator as (*mut BlockTypeCodeCalculator),
                      *types.offset(i as (isize))
                  );
            if i != 0i32 as (usize) {
                let _rhs = 1;
                let _lhs = &mut type_histo[type_code];
                *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
            }
            {
                let _rhs = 1;
                let _lhs
                    = &mut length_histo[
                               BlockLengthPrefixCode(*lengths.offset(i as (isize))) as (usize)
                           ];
                *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
            }
        }
        i = i.wrapping_add(1 as (usize));
    }
    StoreVarLenUint8(
        num_types.wrapping_sub(1i32 as (usize)),
        storage_ix,
        storage
    );
    if num_types > 1i32 as (usize) {
        BuildAndStoreHuffmanTree(
            &mut type_histo[0i32 as (usize)] as (*mut u32) as (*const u32),
            num_types.wrapping_add(2i32 as (usize)),
            tree,
            &mut (*code).type_depths[0i32 as (usize)] as (*mut u8),
            &mut (*code).type_bits[0i32 as (usize)] as (*mut u16),
            storage_ix,
            storage
        );
        BuildAndStoreHuffmanTree(
            &mut length_histo[0i32 as (usize)] as (*mut u32) as (*const u32),
            26i32 as (usize),
            tree,
            &mut (*code).length_depths[0i32 as (usize)] as (*mut u8),
            &mut (*code).length_bits[0i32 as (usize)] as (*mut u16),
            storage_ix,
            storage
        );
        StoreBlockSwitch(
            code,
            *lengths.offset(0i32 as (isize)),
            *types.offset(0i32 as (isize)),
            1i32,
            storage_ix,
            storage
        );
    }
}

unsafe extern fn BuildAndStoreBlockSwitchEntropyCodes(
    mut self : *mut BlockEncoder,
    mut tree : *mut HuffmanTree,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    BuildAndStoreBlockSplitCode(
        (*self).block_types_,
        (*self).block_lengths_,
        (*self).num_blocks_,
        (*self).num_block_types_,
        tree,
        &mut (*self).block_split_code_ as (*mut BlockSplitCode),
        storage_ix,
        storage
    );
}

unsafe extern fn StoreTrivialContextMap(
    mut num_types : usize,
    mut context_bits : usize,
    mut tree : *mut HuffmanTree,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    StoreVarLenUint8(
        num_types.wrapping_sub(1i32 as (usize)),
        storage_ix,
        storage
    );
    if num_types > 1i32 as (usize) {
        let mut repeat_code
            : usize
            = context_bits.wrapping_sub(1u32 as (usize));
        let mut repeat_bits
            : usize
            = (1u32 << repeat_code).wrapping_sub(1u32) as (usize);
        let mut alphabet_size
            : usize
            = num_types.wrapping_add(repeat_code);
        let mut histogram : [u32; 272];
        let mut depths : [u8; 272];
        let mut bits : [u16; 272];
        let mut i : usize;
        memset(
            histogram.as_mut_ptr() as (*mut ::std::os::raw::c_void),
            0i32,
            alphabet_size.wrapping_mul(::std::mem::size_of::<u32>())
        );
        BrotliWriteBits(
            1i32 as (usize),
            1i32 as (usize),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            4i32 as (usize),
            repeat_code.wrapping_sub(1i32 as (usize)),
            storage_ix,
            storage
        );
        histogram[repeat_code] = num_types as (u32);
        histogram[0i32 as (usize)] = 1i32 as (u32);
        i = context_bits;
        while i < alphabet_size {
            {
                histogram[i] = 1i32 as (u32);
            }
            i = i.wrapping_add(1 as (usize));
        }
        BuildAndStoreHuffmanTree(
            histogram.as_mut_ptr() as (*const u32),
            alphabet_size,
            tree,
            depths.as_mut_ptr(),
            bits.as_mut_ptr(),
            storage_ix,
            storage
        );
        i = 0i32 as (usize);
        while i < num_types {
            {
                let mut code
                    : usize
                    = if i == 0i32 as (usize) {
                          0i32 as (usize)
                      } else {
                          i.wrapping_add(context_bits).wrapping_sub(1i32 as (usize))
                      };
                BrotliWriteBits(
                    depths[code] as (usize),
                    bits[code] as (usize),
                    storage_ix,
                    storage
                );
                BrotliWriteBits(
                    depths[repeat_code] as (usize),
                    bits[repeat_code] as (usize),
                    storage_ix,
                    storage
                );
                BrotliWriteBits(repeat_code,repeat_bits,storage_ix,storage);
            }
            i = i.wrapping_add(1 as (usize));
        }
        BrotliWriteBits(
            1i32 as (usize),
            1i32 as (usize),
            storage_ix,
            storage
        );
    }
}

unsafe extern fn IndexOf(
    mut v : *const u8, mut v_size : usize, mut value : u8
) -> usize {
    let mut i : usize = 0i32 as (usize);
    while i < v_size {
        {
            if *v.offset(i as (isize)) as (i32) == value as (i32) {
                return i;
            }
        }
        i = i.wrapping_add(1 as (usize));
    }
    i
}

unsafe extern fn MoveToFront(mut v : *mut u8, mut index : usize) {
    let mut value : u8 = *v.offset(index as (isize));
    let mut i : usize;
    i = index;
    while i != 0i32 as (usize) {
        {
            *v.offset(i as (isize)) = *v.offset(
                                           i.wrapping_sub(1i32 as (usize)) as (isize)
                                       );
        }
        i = i.wrapping_sub(1 as (usize));
    }
    *v.offset(0i32 as (isize)) = value;
}

unsafe extern fn MoveToFrontTransform(
    mut v_in : *const u32, v_size : usize, mut v_out : *mut u32
) {
    let mut i : usize;
    let mut mtf : [u8; 256];
    let mut max_value : u32;
    if v_size == 0i32 as (usize) {
        return;
    }
    max_value = *v_in.offset(0i32 as (isize));
    i = 1i32 as (usize);
    while i < v_size {
        {
            if *v_in.offset(i as (isize)) > max_value {
                max_value = *v_in.offset(i as (isize));
            }
        }
        i = i.wrapping_add(1 as (usize));
    }
    0i32;
    i = 0i32 as (usize);
    while i <= max_value as (usize) {
        {
            mtf[i] = i as (u8);
        }
        i = i.wrapping_add(1 as (usize));
    }
    {
        let mut mtf_size
            : usize
            = max_value.wrapping_add(1i32 as (u32)) as (usize);
        i = 0i32 as (usize);
        while i < v_size {
            {
                let mut index
                    : usize
                    = IndexOf(
                          mtf.as_mut_ptr() as (*const u8),
                          mtf_size,
                          *v_in.offset(i as (isize)) as (u8)
                      );
                0i32;
                *v_out.offset(i as (isize)) = index as (u32);
                MoveToFront(mtf.as_mut_ptr(),index);
            }
            i = i.wrapping_add(1 as (usize));
        }
    }
}

unsafe extern fn brotli_max_uint32_t(
    mut a : u32, mut b : u32
) -> u32 {
    if a > b { a } else { b }
}

unsafe extern fn brotli_min_uint32_t(
    mut a : u32, mut b : u32
) -> u32 {
    if a < b { a } else { b }
}

unsafe extern fn RunLengthCodeZeros(
    in_size : usize,
    mut v : *mut u32,
    mut out_size : *mut usize,
    mut max_run_length_prefix : *mut u32
) {
    let mut max_reps : u32 = 0i32 as (u32);
    let mut i : usize;
    let mut max_prefix : u32;
    i = 0i32 as (usize);
    while i < in_size {
        let mut reps : u32 = 0i32 as (u32);
        while i < in_size && (*v.offset(i as (isize)) != 0i32 as (u32)) {
            i = i.wrapping_add(1 as (usize));
        }
        while i < in_size && (*v.offset(i as (isize)) == 0i32 as (u32)) {
            {
                reps = reps.wrapping_add(1 as (u32));
            }
            i = i.wrapping_add(1 as (usize));
        }
        max_reps = brotli_max_uint32_t(reps,max_reps);
    }
    max_prefix = if max_reps > 0i32 as (u32) {
                     Log2FloorNonZero(max_reps as (usize))
                 } else {
                     0i32 as (u32)
                 };
    max_prefix = brotli_min_uint32_t(
                     max_prefix,
                     *max_run_length_prefix
                 );
    *max_run_length_prefix = max_prefix;
    *out_size = 0i32 as (usize);
    i = 0i32 as (usize);
    while i < in_size {
        0i32;
        if *v.offset(i as (isize)) != 0i32 as (u32) {
            *v.offset(*out_size as (isize)) = (*v.offset(
                                                    i as (isize)
                                                )).wrapping_add(
                                                  *max_run_length_prefix
                                              );
            i = i.wrapping_add(1 as (usize));
            *out_size = (*out_size).wrapping_add(1 as (usize));
        } else {
            let mut reps : u32 = 1i32 as (u32);
            let mut k : usize;
            k = i.wrapping_add(1i32 as (usize));
            while k < in_size && (*v.offset(k as (isize)) == 0i32 as (u32)) {
                {
                    reps = reps.wrapping_add(1 as (u32));
                }
                k = k.wrapping_add(1 as (usize));
            }
            i = i.wrapping_add(reps as (usize));
            while reps != 0i32 as (u32) {
                if reps < 2u32 << max_prefix {
                    let mut run_length_prefix
                        : u32
                        = Log2FloorNonZero(reps as (usize));
                    let extra_bits
                        : u32
                        = reps.wrapping_sub(1u32 << run_length_prefix);
                    *v.offset(*out_size as (isize)) = run_length_prefix.wrapping_add(
                                                          extra_bits << 9i32
                                                      );
                    *out_size = (*out_size).wrapping_add(1 as (usize));
                    {
                        if 1337i32 != 0 {
                            break;
                        }
                    }
                } else {
                    let extra_bits : u32 = (1u32 << max_prefix).wrapping_sub(1u32);
                    *v.offset(*out_size as (isize)) = max_prefix.wrapping_add(
                                                          extra_bits << 9i32
                                                      );
                    reps = reps.wrapping_sub((2u32 << max_prefix).wrapping_sub(1u32));
                    *out_size = (*out_size).wrapping_add(1 as (usize));
                }
            }
        }
    }
}

unsafe extern fn EncodeContextMap(
    mut m : *mut MemoryManager,
    mut context_map : *const u32,
    mut context_map_size : usize,
    mut num_clusters : usize,
    mut tree : *mut HuffmanTree,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    let mut i : usize;
    let mut rle_symbols : *mut u32;
    let mut max_run_length_prefix : u32 = 6i32 as (u32);
    let mut num_rle_symbols : usize = 0i32 as (usize);
    let mut histogram : [u32; 272];
    static kSymbolMask : u32 = (1u32 << 9i32).wrapping_sub(1u32);
    let mut depths : [u8; 272];
    let mut bits : [u16; 272];
    StoreVarLenUint8(
        num_clusters.wrapping_sub(1i32 as (usize)),
        storage_ix,
        storage
    );
    if num_clusters == 1i32 as (usize) {
        return;
    }
    rle_symbols = if context_map_size != 0 {
                      BrotliAllocate(
                          m,
                          context_map_size.wrapping_mul(::std::mem::size_of::<u32>())
                      ) as (*mut u32)
                  } else {
                      0i32 as (*mut ::std::os::raw::c_void) as (*mut u32)
                  };
    if !(0i32 == 0) {
        return;
    }
    MoveToFrontTransform(context_map,context_map_size,rle_symbols);
    RunLengthCodeZeros(
        context_map_size,
        rle_symbols,
        &mut num_rle_symbols as (*mut usize),
        &mut max_run_length_prefix as (*mut u32)
    );
    memset(
        histogram.as_mut_ptr() as (*mut ::std::os::raw::c_void),
        0i32,
        ::std::mem::size_of::<[u32; 272]>()
    );
    i = 0i32 as (usize);
    while i < num_rle_symbols {
        {
            let _rhs = 1;
            let _lhs
                = &mut histogram[
                           (*rle_symbols.offset(i as (isize)) & kSymbolMask) as (usize)
                       ];
            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
        }
        i = i.wrapping_add(1 as (usize));
    }
    {
        let mut use_rle
            : i32
            = if !!(max_run_length_prefix > 0i32 as (u32)) {
                  1i32
              } else {
                  0i32
              };
        BrotliWriteBits(
            1i32 as (usize),
            use_rle as (usize),
            storage_ix,
            storage
        );
        if use_rle != 0 {
            BrotliWriteBits(
                4i32 as (usize),
                max_run_length_prefix.wrapping_sub(1i32 as (u32)) as (usize),
                storage_ix,
                storage
            );
        }
    }
    BuildAndStoreHuffmanTree(
        histogram.as_mut_ptr() as (*const u32),
        num_clusters.wrapping_add(max_run_length_prefix as (usize)),
        tree,
        depths.as_mut_ptr(),
        bits.as_mut_ptr(),
        storage_ix,
        storage
    );
    i = 0i32 as (usize);
    while i < num_rle_symbols {
        {
            let rle_symbol
                : u32
                = *rle_symbols.offset(i as (isize)) & kSymbolMask;
            let extra_bits_val
                : u32
                = *rle_symbols.offset(i as (isize)) >> 9i32;
            BrotliWriteBits(
                depths[rle_symbol as (usize)] as (usize),
                bits[rle_symbol as (usize)] as (usize),
                storage_ix,
                storage
            );
            if rle_symbol > 0i32 as (u32) && (rle_symbol <= max_run_length_prefix) {
                BrotliWriteBits(
                    rle_symbol as (usize),
                    extra_bits_val as (usize),
                    storage_ix,
                    storage
                );
            }
        }
        i = i.wrapping_add(1 as (usize));
    }
    BrotliWriteBits(
        1i32 as (usize),
        1i32 as (usize),
        storage_ix,
        storage
    );
    {
        BrotliFree(m,rle_symbols as (*mut ::std::os::raw::c_void));
        rle_symbols = 0i32 as (*mut ::std::os::raw::c_void) as (*mut u32);
    }
}

unsafe extern fn BuildAndStoreEntropyCodesLiteral(
    mut m : *mut MemoryManager,
    mut self : *mut BlockEncoder,
    mut histograms : *const HistogramLiteral,
    histograms_size : usize,
    mut tree : *mut HuffmanTree,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    let alphabet_size : usize = (*self).alphabet_size_;
    let table_size
        : usize
        = histograms_size.wrapping_mul(alphabet_size);
    (*self).depths_ = if table_size != 0 {
                          BrotliAllocate(
                              m,
                              table_size.wrapping_mul(::std::mem::size_of::<u8>())
                          ) as (*mut u8)
                      } else {
                          0i32 as (*mut ::std::os::raw::c_void) as (*mut u8)
                      };
    (*self).bits_ = if table_size != 0 {
                        BrotliAllocate(
                            m,
                            table_size.wrapping_mul(::std::mem::size_of::<u16>())
                        ) as (*mut u16)
                    } else {
                        0i32 as (*mut ::std::os::raw::c_void) as (*mut u16)
                    };
    if !(0i32 == 0) {
        return;
    }
    {
        let mut i : usize;
        i = 0i32 as (usize);
        while i < histograms_size {
            {
                let mut ix : usize = i.wrapping_mul(alphabet_size);
                BuildAndStoreHuffmanTree(
                    &mut (*histograms.offset(i as (isize))).data_[
                             0i32 as (usize)
                         ] as (*mut u32) as (*const u32),
                    alphabet_size,
                    tree,
                    &mut *(*self).depths_.offset(ix as (isize)) as (*mut u8),
                    &mut *(*self).bits_.offset(ix as (isize)) as (*mut u16),
                    storage_ix,
                    storage
                );
            }
            i = i.wrapping_add(1 as (usize));
        }
    }
}

unsafe extern fn BuildAndStoreEntropyCodesCommand(
    mut m : *mut MemoryManager,
    mut self : *mut BlockEncoder,
    mut histograms : *const HistogramCommand,
    histograms_size : usize,
    mut tree : *mut HuffmanTree,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    let alphabet_size : usize = (*self).alphabet_size_;
    let table_size
        : usize
        = histograms_size.wrapping_mul(alphabet_size);
    (*self).depths_ = if table_size != 0 {
                          BrotliAllocate(
                              m,
                              table_size.wrapping_mul(::std::mem::size_of::<u8>())
                          ) as (*mut u8)
                      } else {
                          0i32 as (*mut ::std::os::raw::c_void) as (*mut u8)
                      };
    (*self).bits_ = if table_size != 0 {
                        BrotliAllocate(
                            m,
                            table_size.wrapping_mul(::std::mem::size_of::<u16>())
                        ) as (*mut u16)
                    } else {
                        0i32 as (*mut ::std::os::raw::c_void) as (*mut u16)
                    };
    if !(0i32 == 0) {
        return;
    }
    {
        let mut i : usize;
        i = 0i32 as (usize);
        while i < histograms_size {
            {
                let mut ix : usize = i.wrapping_mul(alphabet_size);
                BuildAndStoreHuffmanTree(
                    &mut (*histograms.offset(i as (isize))).data_[
                             0i32 as (usize)
                         ] as (*mut u32) as (*const u32),
                    alphabet_size,
                    tree,
                    &mut *(*self).depths_.offset(ix as (isize)) as (*mut u8),
                    &mut *(*self).bits_.offset(ix as (isize)) as (*mut u16),
                    storage_ix,
                    storage
                );
            }
            i = i.wrapping_add(1 as (usize));
        }
    }
}

unsafe extern fn BuildAndStoreEntropyCodesDistance(
    mut m : *mut MemoryManager,
    mut self : *mut BlockEncoder,
    mut histograms : *const HistogramDistance,
    histograms_size : usize,
    mut tree : *mut HuffmanTree,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    let alphabet_size : usize = (*self).alphabet_size_;
    let table_size
        : usize
        = histograms_size.wrapping_mul(alphabet_size);
    (*self).depths_ = if table_size != 0 {
                          BrotliAllocate(
                              m,
                              table_size.wrapping_mul(::std::mem::size_of::<u8>())
                          ) as (*mut u8)
                      } else {
                          0i32 as (*mut ::std::os::raw::c_void) as (*mut u8)
                      };
    (*self).bits_ = if table_size != 0 {
                        BrotliAllocate(
                            m,
                            table_size.wrapping_mul(::std::mem::size_of::<u16>())
                        ) as (*mut u16)
                    } else {
                        0i32 as (*mut ::std::os::raw::c_void) as (*mut u16)
                    };
    if !(0i32 == 0) {
        return;
    }
    {
        let mut i : usize;
        i = 0i32 as (usize);
        while i < histograms_size {
            {
                let mut ix : usize = i.wrapping_mul(alphabet_size);
                BuildAndStoreHuffmanTree(
                    &mut (*histograms.offset(i as (isize))).data_[
                             0i32 as (usize)
                         ] as (*mut u32) as (*const u32),
                    alphabet_size,
                    tree,
                    &mut *(*self).depths_.offset(ix as (isize)) as (*mut u8),
                    &mut *(*self).bits_.offset(ix as (isize)) as (*mut u16),
                    storage_ix,
                    storage
                );
            }
            i = i.wrapping_add(1 as (usize));
        }
    }
}

unsafe extern fn StoreSymbol(
    mut self : *mut BlockEncoder,
    mut symbol : usize,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    if (*self).block_len_ == 0i32 as (usize) {
        let mut block_ix
            : usize
            = {
                  (*self).block_ix_ = (*self).block_ix_.wrapping_add(1 as (usize));
                  (*self).block_ix_
              };
        let mut block_len
            : u32
            = *(*self).block_lengths_.offset(block_ix as (isize));
        let mut block_type
            : u8
            = *(*self).block_types_.offset(block_ix as (isize));
        (*self).block_len_ = block_len as (usize);
        (*self).entropy_ix_ = (block_type as (usize)).wrapping_mul(
                                  (*self).alphabet_size_
                              );
        StoreBlockSwitch(
            &mut (*self).block_split_code_ as (*mut BlockSplitCode),
            block_len,
            block_type,
            0i32,
            storage_ix,
            storage
        );
    }
    (*self).block_len_ = (*self).block_len_.wrapping_sub(1 as (usize));
    {
        let mut ix : usize = (*self).entropy_ix_.wrapping_add(symbol);
        BrotliWriteBits(
            *(*self).depths_.offset(ix as (isize)) as (usize),
            *(*self).bits_.offset(ix as (isize)) as (usize),
            storage_ix,
            storage
        );
    }
}

unsafe extern fn CommandCopyLenCode(
    mut self : *const Command
) -> u32 {
    (*self).copy_len_ & 0xffffffi32 as (u32) ^ (*self).copy_len_ >> 24i32
}

unsafe extern fn GetInsertLengthCode(
    mut insertlen : usize
) -> u16 {
    if insertlen < 6i32 as (usize) {
        insertlen as (u16)
    } else if insertlen < 130i32 as (usize) {
        let mut nbits
            : u32
            = Log2FloorNonZero(
                  insertlen.wrapping_sub(2i32 as (usize))
              ).wrapping_sub(
                  1u32
              );
        ((nbits << 1i32) as (usize)).wrapping_add(
            insertlen.wrapping_sub(2i32 as (usize)) >> nbits
        ).wrapping_add(
            2i32 as (usize)
        ) as (u16)
    } else if insertlen < 2114i32 as (usize) {
        Log2FloorNonZero(
            insertlen.wrapping_sub(66i32 as (usize))
        ).wrapping_add(
            10i32 as (u32)
        ) as (u16)
    } else if insertlen < 6210i32 as (usize) {
        21u32 as (u16)
    } else if insertlen < 22594i32 as (usize) {
        22u32 as (u16)
    } else {
        23u32 as (u16)
    }
}

unsafe extern fn GetCopyLengthCode(mut copylen : usize) -> u16 {
    if copylen < 10i32 as (usize) {
        copylen.wrapping_sub(2i32 as (usize)) as (u16)
    } else if copylen < 134i32 as (usize) {
        let mut nbits
            : u32
            = Log2FloorNonZero(
                  copylen.wrapping_sub(6i32 as (usize))
              ).wrapping_sub(
                  1u32
              );
        ((nbits << 1i32) as (usize)).wrapping_add(
            copylen.wrapping_sub(6i32 as (usize)) >> nbits
        ).wrapping_add(
            4i32 as (usize)
        ) as (u16)
    } else if copylen < 2118i32 as (usize) {
        Log2FloorNonZero(
            copylen.wrapping_sub(70i32 as (usize))
        ).wrapping_add(
            12i32 as (u32)
        ) as (u16)
    } else {
        23u32 as (u16)
    }
}

unsafe extern fn GetInsertExtra(mut inscode : u16) -> u32 {
    kInsExtra[inscode as (usize)]
}

unsafe extern fn GetInsertBase(mut inscode : u16) -> u32 {
    kInsBase[inscode as (usize)]
}

unsafe extern fn GetCopyBase(mut copycode : u16) -> u32 {
    kCopyBase[copycode as (usize)]
}

unsafe extern fn GetCopyExtra(mut copycode : u16) -> u32 {
    kCopyExtra[copycode as (usize)]
}

unsafe extern fn StoreCommandExtra(
    mut cmd : *const Command,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    let mut copylen_code : u32 = CommandCopyLenCode(cmd);
    let mut inscode
        : u16
        = GetInsertLengthCode((*cmd).insert_len_ as (usize));
    let mut copycode
        : u16
        = GetCopyLengthCode(copylen_code as (usize));
    let mut insnumextra : u32 = GetInsertExtra(inscode);
    let mut insextraval
        : usize
        = (*cmd).insert_len_.wrapping_sub(
              GetInsertBase(inscode)
          ) as (usize);
    let mut copyextraval
        : usize
        = copylen_code.wrapping_sub(GetCopyBase(copycode)) as (usize);
    let mut bits : usize = copyextraval << insnumextra | insextraval;
    BrotliWriteBits(
        insnumextra.wrapping_add(GetCopyExtra(copycode)) as (usize),
        bits,
        storage_ix,
        storage
    );
}

unsafe extern fn Context(
    mut p1 : u8, mut p2 : u8, mut mode : ContextType
) -> u8 {
    if mode as (i32) == ContextType::CONTEXT_LSB6 as (i32) {
        return (p1 as (i32) & 0x3fi32) as (u8);
    }
    if mode as (i32) == ContextType::CONTEXT_MSB6 as (i32) {
        return (p1 as (i32) >> 2i32) as (u8);
    }
    if mode as (i32) == ContextType::CONTEXT_UTF8 as (i32) {
        return
            (kUTF8ContextLookup[p1 as (usize)] as (i32) | kUTF8ContextLookup[
                                                              (p2 as (i32) + 256i32) as (usize)
                                                          ] as (i32)) as (u8);
    }
    if mode as (i32) == ContextType::CONTEXT_SIGNED as (i32) {
        return
            ((kSigned3BitContextLookup[
                  p1 as (usize)
              ] as (i32) << 3i32) + kSigned3BitContextLookup[
                                        p2 as (usize)
                                    ] as (i32)) as (u8);
    }
    0i32 as (u8)
}

unsafe extern fn StoreSymbolWithContext(
    mut self : *mut BlockEncoder,
    mut symbol : usize,
    mut context : usize,
    mut context_map : *const u32,
    mut storage_ix : *mut usize,
    mut storage : *mut u8,
    context_bits : usize
) {
    if (*self).block_len_ == 0i32 as (usize) {
        let mut block_ix
            : usize
            = {
                  (*self).block_ix_ = (*self).block_ix_.wrapping_add(1 as (usize));
                  (*self).block_ix_
              };
        let mut block_len
            : u32
            = *(*self).block_lengths_.offset(block_ix as (isize));
        let mut block_type
            : u8
            = *(*self).block_types_.offset(block_ix as (isize));
        (*self).block_len_ = block_len as (usize);
        (*self).entropy_ix_ = block_type as (usize) << context_bits;
        StoreBlockSwitch(
            &mut (*self).block_split_code_ as (*mut BlockSplitCode),
            block_len,
            block_type,
            0i32,
            storage_ix,
            storage
        );
    }
    (*self).block_len_ = (*self).block_len_.wrapping_sub(1 as (usize));
    {
        let mut histo_ix
            : usize
            = *context_map.offset(
                   (*self).entropy_ix_.wrapping_add(context) as (isize)
               ) as (usize);
        let mut ix
            : usize
            = histo_ix.wrapping_mul((*self).alphabet_size_).wrapping_add(
                  symbol
              );
        BrotliWriteBits(
            *(*self).depths_.offset(ix as (isize)) as (usize),
            *(*self).bits_.offset(ix as (isize)) as (usize),
            storage_ix,
            storage
        );
    }
}

unsafe extern fn CommandCopyLen(mut self : *const Command) -> u32 {
    (*self).copy_len_ & 0xffffffi32 as (u32)
}

unsafe extern fn CommandDistanceContext(
    mut self : *const Command
) -> u32 {
    let mut r : u32 = ((*self).cmd_prefix_ as (i32) >> 6i32) as (u32);
    let mut c : u32 = ((*self).cmd_prefix_ as (i32) & 7i32) as (u32);
    if (r == 0i32 as (u32) || r == 2i32 as (u32) || r == 4i32 as (u32) || r == 7i32 as (u32)) && (c <= 2i32 as (u32)) {
        return c;
    }
    3i32 as (u32)
}

unsafe extern fn CleanupBlockEncoder(
    mut m : *mut MemoryManager, mut self : *mut BlockEncoder
) {
    {
        BrotliFree(m,(*self).depths_ as (*mut ::std::os::raw::c_void));
        (*self).depths_ = 0i32 as (*mut ::std::os::raw::c_void) as (*mut u8);
    }
    {
        BrotliFree(m,(*self).bits_ as (*mut ::std::os::raw::c_void));
        (*self).bits_ = 0i32 as (*mut ::std::os::raw::c_void) as (*mut u16);
    }
}

unsafe extern fn JumpToByteBoundary(
    mut storage_ix : *mut usize, mut storage : *mut u8
) {
    *storage_ix = (*storage_ix).wrapping_add(
                      7u32 as (usize)
                  ) & !7u32 as (usize);
    *storage.offset((*storage_ix >> 3i32) as (isize)) = 0i32 as (u8);
}

#[no_mangle]
pub unsafe extern fn BrotliStoreMetaBlock(
    mut m : *mut MemoryManager,
    mut input : *const u8,
    mut start_pos : usize,
    mut length : usize,
    mut mask : usize,
    mut prev_byte : u8,
    mut prev_byte2 : u8,
    mut is_last : i32,
    mut num_direct_distance_codes : u32,
    mut distance_postfix_bits : u32,
    mut literal_context_mode : ContextType,
    mut commands : *const Command,
    mut n_commands : usize,
    mut mb : *const MetaBlockSplit,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    let mut pos : usize = start_pos;
    let mut i : usize;
    let mut num_distance_codes
        : usize
        = (16i32 as (u32)).wrapping_add(
              num_direct_distance_codes
          ).wrapping_add(
              48u32 << distance_postfix_bits
          ) as (usize);
    let mut tree : *mut HuffmanTree;
    let mut literal_enc : BlockEncoder;
    let mut command_enc : BlockEncoder;
    let mut distance_enc : BlockEncoder;
    StoreCompressedMetaBlockHeader(is_last,length,storage_ix,storage);
    tree = if 2i32 * 704i32 + 1i32 != 0 {
               BrotliAllocate(
                   m,
                   ((2i32 * 704i32 + 1i32) as (usize)).wrapping_mul(
                       ::std::mem::size_of::<HuffmanTree>()
                   )
               ) as (*mut HuffmanTree)
           } else {
               0i32 as (*mut ::std::os::raw::c_void) as (*mut HuffmanTree)
           };
    if !(0i32 == 0) {
        return;
    }
    InitBlockEncoder(
        &mut literal_enc as (*mut BlockEncoder),
        256i32 as (usize),
        (*mb).literal_split.num_types,
        (*mb).literal_split.types as (*const u8),
        (*mb).literal_split.lengths as (*const u32),
        (*mb).literal_split.num_blocks
    );
    InitBlockEncoder(
        &mut command_enc as (*mut BlockEncoder),
        704i32 as (usize),
        (*mb).command_split.num_types,
        (*mb).command_split.types as (*const u8),
        (*mb).command_split.lengths as (*const u32),
        (*mb).command_split.num_blocks
    );
    InitBlockEncoder(
        &mut distance_enc as (*mut BlockEncoder),
        num_distance_codes,
        (*mb).distance_split.num_types,
        (*mb).distance_split.types as (*const u8),
        (*mb).distance_split.lengths as (*const u32),
        (*mb).distance_split.num_blocks
    );
    BuildAndStoreBlockSwitchEntropyCodes(
        &mut literal_enc as (*mut BlockEncoder),
        tree,
        storage_ix,
        storage
    );
    BuildAndStoreBlockSwitchEntropyCodes(
        &mut command_enc as (*mut BlockEncoder),
        tree,
        storage_ix,
        storage
    );
    BuildAndStoreBlockSwitchEntropyCodes(
        &mut distance_enc as (*mut BlockEncoder),
        tree,
        storage_ix,
        storage
    );
    BrotliWriteBits(
        2i32 as (usize),
        distance_postfix_bits as (usize),
        storage_ix,
        storage
    );
    BrotliWriteBits(
        4i32 as (usize),
        (num_direct_distance_codes >> distance_postfix_bits) as (usize),
        storage_ix,
        storage
    );
    i = 0i32 as (usize);
    while i < (*mb).literal_split.num_types {
        {
            BrotliWriteBits(
                2i32 as (usize),
                literal_context_mode as (usize),
                storage_ix,
                storage
            );
        }
        i = i.wrapping_add(1 as (usize));
    }
    if (*mb).literal_context_map_size == 0i32 as (usize) {
        StoreTrivialContextMap(
            (*mb).literal_histograms_size,
            6i32 as (usize),
            tree,
            storage_ix,
            storage
        );
    } else {
        EncodeContextMap(
            m,
            (*mb).literal_context_map as (*const u32),
            (*mb).literal_context_map_size,
            (*mb).literal_histograms_size,
            tree,
            storage_ix,
            storage
        );
        if !(0i32 == 0) {
            return;
        }
    }
    if (*mb).distance_context_map_size == 0i32 as (usize) {
        StoreTrivialContextMap(
            (*mb).distance_histograms_size,
            2i32 as (usize),
            tree,
            storage_ix,
            storage
        );
    } else {
        EncodeContextMap(
            m,
            (*mb).distance_context_map as (*const u32),
            (*mb).distance_context_map_size,
            (*mb).distance_histograms_size,
            tree,
            storage_ix,
            storage
        );
        if !(0i32 == 0) {
            return;
        }
    }
    BuildAndStoreEntropyCodesLiteral(
        m,
        &mut literal_enc as (*mut BlockEncoder),
        (*mb).literal_histograms as (*const HistogramLiteral),
        (*mb).literal_histograms_size,
        tree,
        storage_ix,
        storage
    );
    if !(0i32 == 0) {
        return;
    }
    BuildAndStoreEntropyCodesCommand(
        m,
        &mut command_enc as (*mut BlockEncoder),
        (*mb).command_histograms as (*const HistogramCommand),
        (*mb).command_histograms_size,
        tree,
        storage_ix,
        storage
    );
    if !(0i32 == 0) {
        return;
    }
    BuildAndStoreEntropyCodesDistance(
        m,
        &mut distance_enc as (*mut BlockEncoder),
        (*mb).distance_histograms as (*const HistogramDistance),
        (*mb).distance_histograms_size,
        tree,
        storage_ix,
        storage
    );
    if !(0i32 == 0) {
        return;
    }
    {
        BrotliFree(m,tree as (*mut ::std::os::raw::c_void));
        tree = 0i32 as (*mut ::std::os::raw::c_void) as (*mut HuffmanTree);
    }
    i = 0i32 as (usize);
    while i < n_commands {
        {
            let cmd : Command = *commands.offset(i as (isize));
            let mut cmd_code : usize = cmd.cmd_prefix_ as (usize);
            StoreSymbol(
                &mut command_enc as (*mut BlockEncoder),
                cmd_code,
                storage_ix,
                storage
            );
            StoreCommandExtra(&cmd as (*const Command),storage_ix,storage);
            if (*mb).literal_context_map_size == 0i32 as (usize) {
                let mut j : usize;
                j = cmd.insert_len_ as (usize);
                while j != 0i32 as (usize) {
                    {
                        StoreSymbol(
                            &mut literal_enc as (*mut BlockEncoder),
                            *input.offset((pos & mask) as (isize)) as (usize),
                            storage_ix,
                            storage
                        );
                        pos = pos.wrapping_add(1 as (usize));
                    }
                    j = j.wrapping_sub(1 as (usize));
                }
            } else {
                let mut j : usize;
                j = cmd.insert_len_ as (usize);
                while j != 0i32 as (usize) {
                    {
                        let mut context
                            : usize
                            = Context(prev_byte,prev_byte2,literal_context_mode) as (usize);
                        let mut literal : u8 = *input.offset((pos & mask) as (isize));
                        StoreSymbolWithContext(
                            &mut literal_enc as (*mut BlockEncoder),
                            literal as (usize),
                            context,
                            (*mb).literal_context_map as (*const u32),
                            storage_ix,
                            storage,
                            6i32 as (usize)
                        );
                        prev_byte2 = prev_byte;
                        prev_byte = literal;
                        pos = pos.wrapping_add(1 as (usize));
                    }
                    j = j.wrapping_sub(1 as (usize));
                }
            }
            pos = pos.wrapping_add(
                      CommandCopyLen(&cmd as (*const Command)) as (usize)
                  );
            if CommandCopyLen(&cmd as (*const Command)) != 0 {
                prev_byte2 = *input.offset(
                                  (pos.wrapping_sub(2i32 as (usize)) & mask) as (isize)
                              );
                prev_byte = *input.offset(
                                 (pos.wrapping_sub(1i32 as (usize)) & mask) as (isize)
                             );
                if cmd.cmd_prefix_ as (i32) >= 128i32 {
                    let mut dist_code : usize = cmd.dist_prefix_ as (usize);
                    let mut distnumextra : u32 = cmd.dist_extra_ >> 24i32;
                    let mut distextra
                        : usize
                        = (cmd.dist_extra_ & 0xffffffi32 as (u32)) as (usize);
                    if (*mb).distance_context_map_size == 0i32 as (usize) {
                        StoreSymbol(
                            &mut distance_enc as (*mut BlockEncoder),
                            dist_code,
                            storage_ix,
                            storage
                        );
                    } else {
                        let mut context
                            : usize
                            = CommandDistanceContext(&cmd as (*const Command)) as (usize);
                        StoreSymbolWithContext(
                            &mut distance_enc as (*mut BlockEncoder),
                            dist_code,
                            context,
                            (*mb).distance_context_map as (*const u32),
                            storage_ix,
                            storage,
                            2i32 as (usize)
                        );
                    }
                    BrotliWriteBits(
                        distnumextra as (usize),
                        distextra,
                        storage_ix,
                        storage
                    );
                }
            }
        }
        i = i.wrapping_add(1 as (usize));
    }
    CleanupBlockEncoder(m,&mut distance_enc as (*mut BlockEncoder));
    CleanupBlockEncoder(m,&mut command_enc as (*mut BlockEncoder));
    CleanupBlockEncoder(m,&mut literal_enc as (*mut BlockEncoder));
    if is_last != 0 {
        JumpToByteBoundary(storage_ix,storage);
    }
}

unsafe extern fn HistogramClearLiteral(
    mut self : *mut HistogramLiteral
) {
    memset(
        (*self).data_.as_mut_ptr() as (*mut ::std::os::raw::c_void),
        0i32,
        ::std::mem::size_of::<[u32; 256]>()
    );
    (*self).total_count_ = 0i32 as (usize);
    (*self).bit_cost_ = 3.402e+38f64;
}

unsafe extern fn HistogramClearCommand(
    mut self : *mut HistogramCommand
) {
    memset(
        (*self).data_.as_mut_ptr() as (*mut ::std::os::raw::c_void),
        0i32,
        ::std::mem::size_of::<[u32; 704]>()
    );
    (*self).total_count_ = 0i32 as (usize);
    (*self).bit_cost_ = 3.402e+38f64;
}

unsafe extern fn HistogramClearDistance(
    mut self : *mut HistogramDistance
) {
    memset(
        (*self).data_.as_mut_ptr() as (*mut ::std::os::raw::c_void),
        0i32,
        ::std::mem::size_of::<[u32; 520]>()
    );
    (*self).total_count_ = 0i32 as (usize);
    (*self).bit_cost_ = 3.402e+38f64;
}

unsafe extern fn HistogramAddCommand(
    mut self : *mut HistogramCommand, mut val : usize
) {
    {
        let _rhs = 1;
        let _lhs = &mut (*self).data_[val];
        *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
    }
    (*self).total_count_ = (*self).total_count_.wrapping_add(
                               1 as (usize)
                           );
}

unsafe extern fn HistogramAddLiteral(
    mut self : *mut HistogramLiteral, mut val : usize
) {
    {
        let _rhs = 1;
        let _lhs = &mut (*self).data_[val];
        *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
    }
    (*self).total_count_ = (*self).total_count_.wrapping_add(
                               1 as (usize)
                           );
}

unsafe extern fn HistogramAddDistance(
    mut self : *mut HistogramDistance, mut val : usize
) {
    {
        let _rhs = 1;
        let _lhs = &mut (*self).data_[val];
        *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
    }
    (*self).total_count_ = (*self).total_count_.wrapping_add(
                               1 as (usize)
                           );
}

unsafe extern fn BuildHistograms(
    mut input : *const u8,
    mut start_pos : usize,
    mut mask : usize,
    mut commands : *const Command,
    mut n_commands : usize,
    mut lit_histo : *mut HistogramLiteral,
    mut cmd_histo : *mut HistogramCommand,
    mut dist_histo : *mut HistogramDistance
) {
    let mut pos : usize = start_pos;
    let mut i : usize;
    i = 0i32 as (usize);
    while i < n_commands {
        {
            let cmd : Command = *commands.offset(i as (isize));
            let mut j : usize;
            HistogramAddCommand(cmd_histo,cmd.cmd_prefix_ as (usize));
            j = cmd.insert_len_ as (usize);
            while j != 0i32 as (usize) {
                {
                    HistogramAddLiteral(
                        lit_histo,
                        *input.offset((pos & mask) as (isize)) as (usize)
                    );
                    pos = pos.wrapping_add(1 as (usize));
                }
                j = j.wrapping_sub(1 as (usize));
            }
            pos = pos.wrapping_add(
                      CommandCopyLen(&cmd as (*const Command)) as (usize)
                  );
            if CommandCopyLen(
                   &cmd as (*const Command)
               ) != 0 && (cmd.cmd_prefix_ as (i32) >= 128i32) {
                HistogramAddDistance(dist_histo,cmd.dist_prefix_ as (usize));
            }
        }
        i = i.wrapping_add(1 as (usize));
    }
}

unsafe extern fn StoreDataWithHuffmanCodes(
    mut input : *const u8,
    mut start_pos : usize,
    mut mask : usize,
    mut commands : *const Command,
    mut n_commands : usize,
    mut lit_depth : *const u8,
    mut lit_bits : *const u16,
    mut cmd_depth : *const u8,
    mut cmd_bits : *const u16,
    mut dist_depth : *const u8,
    mut dist_bits : *const u16,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    let mut pos : usize = start_pos;
    let mut i : usize;
    i = 0i32 as (usize);
    while i < n_commands {
        {
            let cmd : Command = *commands.offset(i as (isize));
            let cmd_code : usize = cmd.cmd_prefix_ as (usize);
            let mut j : usize;
            BrotliWriteBits(
                *cmd_depth.offset(cmd_code as (isize)) as (usize),
                *cmd_bits.offset(cmd_code as (isize)) as (usize),
                storage_ix,
                storage
            );
            StoreCommandExtra(&cmd as (*const Command),storage_ix,storage);
            j = cmd.insert_len_ as (usize);
            while j != 0i32 as (usize) {
                {
                    let literal : u8 = *input.offset((pos & mask) as (isize));
                    BrotliWriteBits(
                        *lit_depth.offset(literal as (isize)) as (usize),
                        *lit_bits.offset(literal as (isize)) as (usize),
                        storage_ix,
                        storage
                    );
                    pos = pos.wrapping_add(1 as (usize));
                }
                j = j.wrapping_sub(1 as (usize));
            }
            pos = pos.wrapping_add(
                      CommandCopyLen(&cmd as (*const Command)) as (usize)
                  );
            if CommandCopyLen(
                   &cmd as (*const Command)
               ) != 0 && (cmd.cmd_prefix_ as (i32) >= 128i32) {
                let dist_code : usize = cmd.dist_prefix_ as (usize);
                let distnumextra : u32 = cmd.dist_extra_ >> 24i32;
                let distextra : u32 = cmd.dist_extra_ & 0xffffffi32 as (u32);
                BrotliWriteBits(
                    *dist_depth.offset(dist_code as (isize)) as (usize),
                    *dist_bits.offset(dist_code as (isize)) as (usize),
                    storage_ix,
                    storage
                );
                BrotliWriteBits(
                    distnumextra as (usize),
                    distextra as (usize),
                    storage_ix,
                    storage
                );
            }
        }
        i = i.wrapping_add(1 as (usize));
    }
}

#[no_mangle]
pub unsafe extern fn BrotliStoreMetaBlockTrivial(
    mut m : *mut MemoryManager,
    mut input : *const u8,
    mut start_pos : usize,
    mut length : usize,
    mut mask : usize,
    mut is_last : i32,
    mut commands : *const Command,
    mut n_commands : usize,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    let mut lit_histo : HistogramLiteral;
    let mut cmd_histo : HistogramCommand;
    let mut dist_histo : HistogramDistance;
    let mut lit_depth : [u8; 256];
    let mut lit_bits : [u16; 256];
    let mut cmd_depth : [u8; 704];
    let mut cmd_bits : [u16; 704];
    let mut dist_depth : [u8; 64];
    let mut dist_bits : [u16; 64];
    let mut tree : *mut HuffmanTree;
    StoreCompressedMetaBlockHeader(is_last,length,storage_ix,storage);
    HistogramClearLiteral(&mut lit_histo as (*mut HistogramLiteral));
    HistogramClearCommand(&mut cmd_histo as (*mut HistogramCommand));
    HistogramClearDistance(
        &mut dist_histo as (*mut HistogramDistance)
    );
    BuildHistograms(
        input,
        start_pos,
        mask,
        commands,
        n_commands,
        &mut lit_histo as (*mut HistogramLiteral),
        &mut cmd_histo as (*mut HistogramCommand),
        &mut dist_histo as (*mut HistogramDistance)
    );
    BrotliWriteBits(
        13i32 as (usize),
        0i32 as (usize),
        storage_ix,
        storage
    );
    tree = if 2i32 * 704i32 + 1i32 != 0 {
               BrotliAllocate(
                   m,
                   ((2i32 * 704i32 + 1i32) as (usize)).wrapping_mul(
                       ::std::mem::size_of::<HuffmanTree>()
                   )
               ) as (*mut HuffmanTree)
           } else {
               0i32 as (*mut ::std::os::raw::c_void) as (*mut HuffmanTree)
           };
    if !(0i32 == 0) {
        return;
    }
    BuildAndStoreHuffmanTree(
        lit_histo.data_.as_mut_ptr() as (*const u32),
        256i32 as (usize),
        tree,
        lit_depth.as_mut_ptr(),
        lit_bits.as_mut_ptr(),
        storage_ix,
        storage
    );
    BuildAndStoreHuffmanTree(
        cmd_histo.data_.as_mut_ptr() as (*const u32),
        704i32 as (usize),
        tree,
        cmd_depth.as_mut_ptr(),
        cmd_bits.as_mut_ptr(),
        storage_ix,
        storage
    );
    BuildAndStoreHuffmanTree(
        dist_histo.data_.as_mut_ptr() as (*const u32),
        64i32 as (usize),
        tree,
        dist_depth.as_mut_ptr(),
        dist_bits.as_mut_ptr(),
        storage_ix,
        storage
    );
    {
        BrotliFree(m,tree as (*mut ::std::os::raw::c_void));
        tree = 0i32 as (*mut ::std::os::raw::c_void) as (*mut HuffmanTree);
    }
    StoreDataWithHuffmanCodes(
        input,
        start_pos,
        mask,
        commands,
        n_commands,
        lit_depth.as_mut_ptr() as (*const u8),
        lit_bits.as_mut_ptr() as (*const u16),
        cmd_depth.as_mut_ptr() as (*const u8),
        cmd_bits.as_mut_ptr() as (*const u16),
        dist_depth.as_mut_ptr() as (*const u8),
        dist_bits.as_mut_ptr() as (*const u16),
        storage_ix,
        storage
    );
    if is_last != 0 {
        JumpToByteBoundary(storage_ix,storage);
    }
}

unsafe extern fn StoreStaticCommandHuffmanTree(
    mut storage_ix : *mut usize, mut storage : *mut u8
) {
    BrotliWriteBits(
        56i32 as (usize),
        0x926244u32 as (usize) << 32i32 | 0x16307003u32 as (usize),
        storage_ix,
        storage
    );
    BrotliWriteBits(
        3i32 as (usize),
        0x0u32 as (usize),
        storage_ix,
        storage
    );
}

unsafe extern fn StoreStaticDistanceHuffmanTree(
    mut storage_ix : *mut usize, mut storage : *mut u8
) {
    BrotliWriteBits(
        28i32 as (usize),
        0x369dc03u32 as (usize),
        storage_ix,
        storage
    );
}

#[no_mangle]
pub unsafe extern fn BrotliStoreMetaBlockFast(
    mut m : *mut MemoryManager,
    mut input : *const u8,
    mut start_pos : usize,
    mut length : usize,
    mut mask : usize,
    mut is_last : i32,
    mut commands : *const Command,
    mut n_commands : usize,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    StoreCompressedMetaBlockHeader(is_last,length,storage_ix,storage);
    BrotliWriteBits(
        13i32 as (usize),
        0i32 as (usize),
        storage_ix,
        storage
    );
    if n_commands <= 128i32 as (usize) {
        let mut histogram
            : [u32; 256]
            = [   0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32),
                  0i32 as (u32)
              ];
        let mut pos : usize = start_pos;
        let mut num_literals : usize = 0i32 as (usize);
        let mut i : usize;
        let mut lit_depth : [u8; 256];
        let mut lit_bits : [u16; 256];
        i = 0i32 as (usize);
        while i < n_commands {
            {
                let cmd : Command = *commands.offset(i as (isize));
                let mut j : usize;
                j = cmd.insert_len_ as (usize);
                while j != 0i32 as (usize) {
                    {
                        {
                            let _rhs = 1;
                            let _lhs
                                = &mut histogram[
                                           *input.offset((pos & mask) as (isize)) as (usize)
                                       ];
                            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
                        }
                        pos = pos.wrapping_add(1 as (usize));
                    }
                    j = j.wrapping_sub(1 as (usize));
                }
                num_literals = num_literals.wrapping_add(
                                   cmd.insert_len_ as (usize)
                               );
                pos = pos.wrapping_add(
                          CommandCopyLen(&cmd as (*const Command)) as (usize)
                      );
            }
            i = i.wrapping_add(1 as (usize));
        }
        BrotliBuildAndStoreHuffmanTreeFast(
            m,
            histogram.as_mut_ptr() as (*const u32),
            num_literals,
            8i32 as (usize),
            lit_depth.as_mut_ptr(),
            lit_bits.as_mut_ptr(),
            storage_ix,
            storage
        );
        if !(0i32 == 0) {
            return;
        }
        StoreStaticCommandHuffmanTree(storage_ix,storage);
        StoreStaticDistanceHuffmanTree(storage_ix,storage);
        StoreDataWithHuffmanCodes(
            input,
            start_pos,
            mask,
            commands,
            n_commands,
            lit_depth.as_mut_ptr() as (*const u8),
            lit_bits.as_mut_ptr() as (*const u16),
            kStaticCommandCodeDepth.as_ptr(),
            kStaticCommandCodeBits.as_ptr(),
            kStaticDistanceCodeDepth.as_ptr(),
            kStaticDistanceCodeBits.as_ptr(),
            storage_ix,
            storage
        );
    } else {
        let mut lit_histo : HistogramLiteral;
        let mut cmd_histo : HistogramCommand;
        let mut dist_histo : HistogramDistance;
        let mut lit_depth : [u8; 256];
        let mut lit_bits : [u16; 256];
        let mut cmd_depth : [u8; 704];
        let mut cmd_bits : [u16; 704];
        let mut dist_depth : [u8; 64];
        let mut dist_bits : [u16; 64];
        HistogramClearLiteral(&mut lit_histo as (*mut HistogramLiteral));
        HistogramClearCommand(&mut cmd_histo as (*mut HistogramCommand));
        HistogramClearDistance(
            &mut dist_histo as (*mut HistogramDistance)
        );
        BuildHistograms(
            input,
            start_pos,
            mask,
            commands,
            n_commands,
            &mut lit_histo as (*mut HistogramLiteral),
            &mut cmd_histo as (*mut HistogramCommand),
            &mut dist_histo as (*mut HistogramDistance)
        );
        BrotliBuildAndStoreHuffmanTreeFast(
            m,
            lit_histo.data_.as_mut_ptr() as (*const u32),
            lit_histo.total_count_,
            8i32 as (usize),
            lit_depth.as_mut_ptr(),
            lit_bits.as_mut_ptr(),
            storage_ix,
            storage
        );
        if !(0i32 == 0) {
            return;
        }
        BrotliBuildAndStoreHuffmanTreeFast(
            m,
            cmd_histo.data_.as_mut_ptr() as (*const u32),
            cmd_histo.total_count_,
            10i32 as (usize),
            cmd_depth.as_mut_ptr(),
            cmd_bits.as_mut_ptr(),
            storage_ix,
            storage
        );
        if !(0i32 == 0) {
            return;
        }
        BrotliBuildAndStoreHuffmanTreeFast(
            m,
            dist_histo.data_.as_mut_ptr() as (*const u32),
            dist_histo.total_count_,
            6i32 as (usize),
            dist_depth.as_mut_ptr(),
            dist_bits.as_mut_ptr(),
            storage_ix,
            storage
        );
        if !(0i32 == 0) {
            return;
        }
        StoreDataWithHuffmanCodes(
            input,
            start_pos,
            mask,
            commands,
            n_commands,
            lit_depth.as_mut_ptr() as (*const u8),
            lit_bits.as_mut_ptr() as (*const u16),
            cmd_depth.as_mut_ptr() as (*const u8),
            cmd_bits.as_mut_ptr() as (*const u16),
            dist_depth.as_mut_ptr() as (*const u8),
            dist_bits.as_mut_ptr() as (*const u16),
            storage_ix,
            storage
        );
    }
    if is_last != 0 {
        JumpToByteBoundary(storage_ix,storage);
    }
}

unsafe extern fn BrotliStoreUncompressedMetaBlockHeader(
    mut length : usize,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    let mut lenbits : usize;
    let mut nlenbits : usize;
    let mut nibblesbits : usize;
    BrotliWriteBits(
        1i32 as (usize),
        0i32 as (usize),
        storage_ix,
        storage
    );
    BrotliEncodeMlen(
        length,
        &mut lenbits as (*mut usize),
        &mut nlenbits as (*mut usize),
        &mut nibblesbits as (*mut usize)
    );
    BrotliWriteBits(2i32 as (usize),nibblesbits,storage_ix,storage);
    BrotliWriteBits(nlenbits,lenbits,storage_ix,storage);
    BrotliWriteBits(
        1i32 as (usize),
        1i32 as (usize),
        storage_ix,
        storage
    );
}

unsafe extern fn BrotliWriteBitsPrepareStorage(
    mut pos : usize, mut array : *mut u8
) {
    0i32;
    *array.offset((pos >> 3i32) as (isize)) = 0i32 as (u8);
}

#[no_mangle]
pub unsafe extern fn BrotliStoreUncompressedMetaBlock(
    mut is_final_block : i32,
    mut input : *const u8,
    mut position : usize,
    mut mask : usize,
    mut len : usize,
    mut storage_ix : *mut usize,
    mut storage : *mut u8
) {
    let mut masked_pos : usize = position & mask;
    BrotliStoreUncompressedMetaBlockHeader(len,storage_ix,storage);
    JumpToByteBoundary(storage_ix,storage);
    if masked_pos.wrapping_add(len) > mask.wrapping_add(
                                          1i32 as (usize)
                                      ) {
        let mut len1
            : usize
            = mask.wrapping_add(1i32 as (usize)).wrapping_sub(masked_pos);
        memcpy(
            &mut *storage.offset(
                      (*storage_ix >> 3i32) as (isize)
                  ) as (*mut u8) as (*mut ::std::os::raw::c_void),
            &*input.offset(
                  masked_pos as (isize)
              ) as (*const u8) as (*const ::std::os::raw::c_void),
            len1
        );
        *storage_ix = (*storage_ix).wrapping_add(len1 << 3i32);
        len = len.wrapping_sub(len1);
        masked_pos = 0i32 as (usize);
    }
    memcpy(
        &mut *storage.offset(
                  (*storage_ix >> 3i32) as (isize)
              ) as (*mut u8) as (*mut ::std::os::raw::c_void),
        &*input.offset(
              masked_pos as (isize)
          ) as (*const u8) as (*const ::std::os::raw::c_void),
        len
    );
    *storage_ix = (*storage_ix).wrapping_add(len << 3i32);
    BrotliWriteBitsPrepareStorage(*storage_ix,storage);
    if is_final_block != 0 {
        BrotliWriteBits(
            1i32 as (usize),
            1i32 as (usize),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            1i32 as (usize),
            1i32 as (usize),
            storage_ix,
            storage
        );
        JumpToByteBoundary(storage_ix,storage);
    }
}

#[no_mangle]
pub unsafe extern fn BrotliStoreSyncMetaBlock(
    mut storage_ix : *mut usize, mut storage : *mut u8
) {
    BrotliWriteBits(
        6i32 as (usize),
        6i32 as (usize),
        storage_ix,
        storage
    );
    JumpToByteBoundary(storage_ix,storage);
}

extern "C" {
  fn BrotliAllocate(m: &mut [MemoryManager], n: usize) -> *mut ::std::os::raw::c_void;
  fn BrotliBuildHistogramsWithContext(cmds: &[Command],
                                      num_commands: usize,
                                      literal_split: &[BlockSplit],
                                      insert_and_copy_split: &[BlockSplit],
                                      dist_split: &[BlockSplit],
                                      ringbuffer: &[u8],
                                      pos: usize,
                                      mask: usize,
                                      prev_byte: u8,
                                      prev_byte2: u8,
                                      context_modes: &[ContextType],
                                      literal_histograms: &mut [HistogramLiteral],
                                      insert_and_copy_histograms: &mut [HistogramCommand],
                                      copy_dist_histograms: &mut [HistogramDistance]);
  fn BrotliClusterHistogramsDistance(m: &mut [MemoryManager],
                                     inp: &[HistogramDistance],
                                     in_size: usize,
                                     max_histograms: usize,
                                     out: &mut [HistogramDistance],
                                     out_size: &mut [usize],
                                     histogram_symbols: &mut [u32]);
  fn BrotliClusterHistogramsLiteral(m: &mut [MemoryManager],
                                    inp: &[HistogramLiteral],
                                    in_size: usize,
                                    max_histograms: usize,
                                    out: &mut [HistogramLiteral],
                                    out_size: &mut [usize],
                                    histogram_symbols: &mut [u32]);
  fn BrotliFree(m: &mut [MemoryManager], p: &mut [::std::os::raw::c_void]);
  fn BrotliOptimizeHuffmanCountsForRle(length: usize,
                                       counts: &mut [u32],
                                       good_for_rle: &mut [u8]);
  fn BrotliSplitBlock(m: &mut [MemoryManager],
                      cmds: &[Command],
                      num_commands: usize,
                      data: &[u8],
                      offset: usize,
                      mask: usize,
                      params: &[BrotliEncoderParams],
                      literal_split: &mut [BlockSplit],
                      insert_and_copy_split: &mut [BlockSplit],
                      dist_split: &mut [BlockSplit]);
  fn memcpy(__dst: &mut [::std::os::raw::c_void],
            __src: &[::std::os::raw::c_void],
            __n: usize)
            -> *mut ::std::os::raw::c_void;
  fn memset(__b: &mut [::std::os::raw::c_void],
            __c: i32,
            __len: usize)
            -> *mut ::std::os::raw::c_void;
}

static mut kLog2Table: [f64; 256] = [0.0000000000000000f64,
                                     0.0000000000000000f64,
                                     1.0000000000000000f64,
                                     1.5849625007211563f64,
                                     2.0000000000000000f64,
                                     2.3219280948873622f64,
                                     2.5849625007211561f64,
                                     2.8073549220576042f64,
                                     3.0000000000000000f64,
                                     3.1699250014423126f64,
                                     3.3219280948873626f64,
                                     3.4594316186372978f64,
                                     3.5849625007211565f64,
                                     3.7004397181410922f64,
                                     3.8073549220576037f64,
                                     3.9068905956085187f64,
                                     4.0000000000000000f64,
                                     4.0874628412503400f64,
                                     4.1699250014423122f64,
                                     4.2479275134435852f64,
                                     4.3219280948873626f64,
                                     4.3923174227787607f64,
                                     4.4594316186372973f64,
                                     4.5235619560570131f64,
                                     4.5849625007211570f64,
                                     4.6438561897747244f64,
                                     4.7004397181410926f64,
                                     4.7548875021634691f64,
                                     4.8073549220576037f64,
                                     4.8579809951275728f64,
                                     4.9068905956085187f64,
                                     4.9541963103868758f64,
                                     5.0000000000000000f64,
                                     5.0443941193584534f64,
                                     5.0874628412503400f64,
                                     5.1292830169449664f64,
                                     5.1699250014423122f64,
                                     5.2094533656289501f64,
                                     5.2479275134435852f64,
                                     5.2854022188622487f64,
                                     5.3219280948873626f64,
                                     5.3575520046180838f64,
                                     5.3923174227787607f64,
                                     5.4262647547020979f64,
                                     5.4594316186372973f64,
                                     5.4918530963296748f64,
                                     5.5235619560570131f64,
                                     5.5545888516776376f64,
                                     5.5849625007211570f64,
                                     5.6147098441152083f64,
                                     5.6438561897747244f64,
                                     5.6724253419714961f64,
                                     5.7004397181410926f64,
                                     5.7279204545631996f64,
                                     5.7548875021634691f64,
                                     5.7813597135246599f64,
                                     5.8073549220576046f64,
                                     5.8328900141647422f64,
                                     5.8579809951275719f64,
                                     5.8826430493618416f64,
                                     5.9068905956085187f64,
                                     5.9307373375628867f64,
                                     5.9541963103868758f64,
                                     5.9772799234999168f64,
                                     6.0000000000000000f64,
                                     6.0223678130284544f64,
                                     6.0443941193584534f64,
                                     6.0660891904577721f64,
                                     6.0874628412503400f64,
                                     6.1085244567781700f64,
                                     6.1292830169449672f64,
                                     6.1497471195046822f64,
                                     6.1699250014423122f64,
                                     6.1898245588800176f64,
                                     6.2094533656289510f64,
                                     6.2288186904958804f64,
                                     6.2479275134435861f64,
                                     6.2667865406949019f64,
                                     6.2854022188622487f64,
                                     6.3037807481771031f64,
                                     6.3219280948873617f64,
                                     6.3398500028846252f64,
                                     6.3575520046180847f64,
                                     6.3750394313469254f64,
                                     6.3923174227787598f64,
                                     6.4093909361377026f64,
                                     6.4262647547020979f64,
                                     6.4429434958487288f64,
                                     6.4594316186372982f64,
                                     6.4757334309663976f64,
                                     6.4918530963296748f64,
                                     6.5077946401986964f64,
                                     6.5235619560570131f64,
                                     6.5391588111080319f64,
                                     6.5545888516776376f64,
                                     6.5698556083309478f64,
                                     6.5849625007211561f64,
                                     6.5999128421871278f64,
                                     6.6147098441152092f64,
                                     6.6293566200796095f64,
                                     6.6438561897747253f64,
                                     6.6582114827517955f64,
                                     6.6724253419714952f64,
                                     6.6865005271832185f64,
                                     6.7004397181410917f64,
                                     6.7142455176661224f64,
                                     6.7279204545631988f64,
                                     6.7414669864011465f64,
                                     6.7548875021634691f64,
                                     6.7681843247769260f64,
                                     6.7813597135246599f64,
                                     6.7944158663501062f64,
                                     6.8073549220576037f64,
                                     6.8201789624151887f64,
                                     6.8328900141647422f64,
                                     6.8454900509443757f64,
                                     6.8579809951275719f64,
                                     6.8703647195834048f64,
                                     6.8826430493618416f64,
                                     6.8948177633079437f64,
                                     6.9068905956085187f64,
                                     6.9188632372745955f64,
                                     6.9307373375628867f64,
                                     6.9425145053392399f64,
                                     6.9541963103868758f64,
                                     6.9657842846620879f64,
                                     6.9772799234999168f64,
                                     6.9886846867721664f64,
                                     7.0000000000000000f64,
                                     7.0112272554232540f64,
                                     7.0223678130284544f64,
                                     7.0334230015374501f64,
                                     7.0443941193584534f64,
                                     7.0552824355011898f64,
                                     7.0660891904577721f64,
                                     7.0768155970508317f64,
                                     7.0874628412503400f64,
                                     7.0980320829605272f64,
                                     7.1085244567781700f64,
                                     7.1189410727235076f64,
                                     7.1292830169449664f64,
                                     7.1395513523987937f64,
                                     7.1497471195046822f64,
                                     7.1598713367783891f64,
                                     7.1699250014423130f64,
                                     7.1799090900149345f64,
                                     7.1898245588800176f64,
                                     7.1996723448363644f64,
                                     7.2094533656289492f64,
                                     7.2191685204621621f64,
                                     7.2288186904958804f64,
                                     7.2384047393250794f64,
                                     7.2479275134435861f64,
                                     7.2573878426926521f64,
                                     7.2667865406949019f64,
                                     7.2761244052742384f64,
                                     7.2854022188622487f64,
                                     7.2946207488916270f64,
                                     7.3037807481771031f64,
                                     7.3128829552843557f64,
                                     7.3219280948873617f64,
                                     7.3309168781146177f64,
                                     7.3398500028846243f64,
                                     7.3487281542310781f64,
                                     7.3575520046180847f64,
                                     7.3663222142458151f64,
                                     7.3750394313469254f64,
                                     7.3837042924740528f64,
                                     7.3923174227787607f64,
                                     7.4008794362821844f64,
                                     7.4093909361377026f64,
                                     7.4178525148858991f64,
                                     7.4262647547020979f64,
                                     7.4346282276367255f64,
                                     7.4429434958487288f64,
                                     7.4512111118323299f64,
                                     7.4594316186372973f64,
                                     7.4676055500829976f64,
                                     7.4757334309663976f64,
                                     7.4838157772642564f64,
                                     7.4918530963296748f64,
                                     7.4998458870832057f64,
                                     7.5077946401986964f64,
                                     7.5156998382840436f64,
                                     7.5235619560570131f64,
                                     7.5313814605163119f64,
                                     7.5391588111080319f64,
                                     7.5468944598876373f64,
                                     7.5545888516776376f64,
                                     7.5622424242210728f64,
                                     7.5698556083309478f64,
                                     7.5774288280357487f64,
                                     7.5849625007211561f64,
                                     7.5924570372680806f64,
                                     7.5999128421871278f64,
                                     7.6073303137496113f64,
                                     7.6147098441152075f64,
                                     7.6220518194563764f64,
                                     7.6293566200796095f64,
                                     7.6366246205436488f64,
                                     7.6438561897747244f64,
                                     7.6510516911789290f64,
                                     7.6582114827517955f64,
                                     7.6653359171851765f64,
                                     7.6724253419714952f64,
                                     7.6794800995054464f64,
                                     7.6865005271832185f64,
                                     7.6934869574993252f64,
                                     7.7004397181410926f64,
                                     7.7073591320808825f64,
                                     7.7142455176661224f64,
                                     7.7210991887071856f64,
                                     7.7279204545631996f64,
                                     7.7347096202258392f64,
                                     7.7414669864011465f64,
                                     7.7481928495894596f64,
                                     7.7548875021634691f64,
                                     7.7615512324444795f64,
                                     7.7681843247769260f64,
                                     7.7747870596011737f64,
                                     7.7813597135246608f64,
                                     7.7879025593914317f64,
                                     7.7944158663501062f64,
                                     7.8008998999203047f64,
                                     7.8073549220576037f64,
                                     7.8137811912170374f64,
                                     7.8201789624151887f64,
                                     7.8265484872909159f64,
                                     7.8328900141647422f64,
                                     7.8392037880969445f64,
                                     7.8454900509443757f64,
                                     7.8517490414160571f64,
                                     7.8579809951275719f64,
                                     7.8641861446542798f64,
                                     7.8703647195834048f64,
                                     7.8765169465650002f64,
                                     7.8826430493618425f64,
                                     7.8887432488982601f64,
                                     7.8948177633079446f64,
                                     7.9008668079807496f64,
                                     7.9068905956085187f64,
                                     7.9128893362299619f64,
                                     7.9188632372745955f64,
                                     7.9248125036057813f64,
                                     7.9307373375628867f64,
                                     7.9366379390025719f64,
                                     7.9425145053392399f64,
                                     7.9483672315846778f64,
                                     7.9541963103868758f64,
                                     7.9600019320680806f64,
                                     7.9657842846620870f64,
                                     7.9715435539507720f64,
                                     7.9772799234999168f64,
                                     7.9829935746943104f64,
                                     7.9886846867721664f64,
                                     7.9943534368588578f64];


pub fn log2(mut v: f64) -> f64 {
  if v < 0i32 as (f64) {
    0i32 as (f64)
  } else if v < 256i32 as (f64) {
    kLog2Table[v as (usize)]
  } else {
    let mut count: f64 = 0i32 as (f64);
    while 1i32 != 0 {
      v = v / 2i32 as (f64);
      count = count + 1.0f64;
      if v < 256i32 as (f64) {
        return kLog2Table[v as (usize)] + count;
      }
    }
  }
}

static mut kLog2Table: [f32; 256] = [0.0000000000000000f32,
                                     0.0000000000000000f32,
                                     1.0000000000000000f32,
                                     1.5849625007211563f32,
                                     2.0000000000000000f32,
                                     2.3219280948873622f32,
                                     2.5849625007211561f32,
                                     2.8073549220576042f32,
                                     3.0000000000000000f32,
                                     3.1699250014423126f32,
                                     3.3219280948873626f32,
                                     3.4594316186372978f32,
                                     3.5849625007211565f32,
                                     3.7004397181410922f32,
                                     3.8073549220576037f32,
                                     3.9068905956085187f32,
                                     4.0000000000000000f32,
                                     4.0874628412503400f32,
                                     4.1699250014423122f32,
                                     4.2479275134435852f32,
                                     4.3219280948873626f32,
                                     4.3923174227787607f32,
                                     4.4594316186372973f32,
                                     4.5235619560570131f32,
                                     4.5849625007211570f32,
                                     4.6438561897747244f32,
                                     4.7004397181410926f32,
                                     4.7548875021634691f32,
                                     4.8073549220576037f32,
                                     4.8579809951275728f32,
                                     4.9068905956085187f32,
                                     4.9541963103868758f32,
                                     5.0000000000000000f32,
                                     5.0443941193584534f32,
                                     5.0874628412503400f32,
                                     5.1292830169449664f32,
                                     5.1699250014423122f32,
                                     5.2094533656289501f32,
                                     5.2479275134435852f32,
                                     5.2854022188622487f32,
                                     5.3219280948873626f32,
                                     5.3575520046180838f32,
                                     5.3923174227787607f32,
                                     5.4262647547020979f32,
                                     5.4594316186372973f32,
                                     5.4918530963296748f32,
                                     5.5235619560570131f32,
                                     5.5545888516776376f32,
                                     5.5849625007211570f32,
                                     5.6147098441152083f32,
                                     5.6438561897747244f32,
                                     5.6724253419714961f32,
                                     5.7004397181410926f32,
                                     5.7279204545631996f32,
                                     5.7548875021634691f32,
                                     5.7813597135246599f32,
                                     5.8073549220576046f32,
                                     5.8328900141647422f32,
                                     5.8579809951275719f32,
                                     5.8826430493618416f32,
                                     5.9068905956085187f32,
                                     5.9307373375628867f32,
                                     5.9541963103868758f32,
                                     5.9772799234999168f32,
                                     6.0000000000000000f32,
                                     6.0223678130284544f32,
                                     6.0443941193584534f32,
                                     6.0660891904577721f32,
                                     6.0874628412503400f32,
                                     6.1085244567781700f32,
                                     6.1292830169449672f32,
                                     6.1497471195046822f32,
                                     6.1699250014423122f32,
                                     6.1898245588800176f32,
                                     6.2094533656289510f32,
                                     6.2288186904958804f32,
                                     6.2479275134435861f32,
                                     6.2667865406949019f32,
                                     6.2854022188622487f32,
                                     6.3037807481771031f32,
                                     6.3219280948873617f32,
                                     6.3398500028846252f32,
                                     6.3575520046180847f32,
                                     6.3750394313469254f32,
                                     6.3923174227787598f32,
                                     6.4093909361377026f32,
                                     6.4262647547020979f32,
                                     6.4429434958487288f32,
                                     6.4594316186372982f32,
                                     6.4757334309663976f32,
                                     6.4918530963296748f32,
                                     6.5077946401986964f32,
                                     6.5235619560570131f32,
                                     6.5391588111080319f32,
                                     6.5545888516776376f32,
                                     6.5698556083309478f32,
                                     6.5849625007211561f32,
                                     6.5999128421871278f32,
                                     6.6147098441152092f32,
                                     6.6293566200796095f32,
                                     6.6438561897747253f32,
                                     6.6582114827517955f32,
                                     6.6724253419714952f32,
                                     6.6865005271832185f32,
                                     6.7004397181410917f32,
                                     6.7142455176661224f32,
                                     6.7279204545631988f32,
                                     6.7414669864011465f32,
                                     6.7548875021634691f32,
                                     6.7681843247769260f32,
                                     6.7813597135246599f32,
                                     6.7944158663501062f32,
                                     6.8073549220576037f32,
                                     6.8201789624151887f32,
                                     6.8328900141647422f32,
                                     6.8454900509443757f32,
                                     6.8579809951275719f32,
                                     6.8703647195834048f32,
                                     6.8826430493618416f32,
                                     6.8948177633079437f32,
                                     6.9068905956085187f32,
                                     6.9188632372745955f32,
                                     6.9307373375628867f32,
                                     6.9425145053392399f32,
                                     6.9541963103868758f32,
                                     6.9657842846620879f32,
                                     6.9772799234999168f32,
                                     6.9886846867721664f32,
                                     7.0000000000000000f32,
                                     7.0112272554232540f32,
                                     7.0223678130284544f32,
                                     7.0334230015374501f32,
                                     7.0443941193584534f32,
                                     7.0552824355011898f32,
                                     7.0660891904577721f32,
                                     7.0768155970508317f32,
                                     7.0874628412503400f32,
                                     7.0980320829605272f32,
                                     7.1085244567781700f32,
                                     7.1189410727235076f32,
                                     7.1292830169449664f32,
                                     7.1395513523987937f32,
                                     7.1497471195046822f32,
                                     7.1598713367783891f32,
                                     7.1699250014423130f32,
                                     7.1799090900149345f32,
                                     7.1898245588800176f32,
                                     7.1996723448363644f32,
                                     7.2094533656289492f32,
                                     7.2191685204621621f32,
                                     7.2288186904958804f32,
                                     7.2384047393250794f32,
                                     7.2479275134435861f32,
                                     7.2573878426926521f32,
                                     7.2667865406949019f32,
                                     7.2761244052742384f32,
                                     7.2854022188622487f32,
                                     7.2946207488916270f32,
                                     7.3037807481771031f32,
                                     7.3128829552843557f32,
                                     7.3219280948873617f32,
                                     7.3309168781146177f32,
                                     7.3398500028846243f32,
                                     7.3487281542310781f32,
                                     7.3575520046180847f32,
                                     7.3663222142458151f32,
                                     7.3750394313469254f32,
                                     7.3837042924740528f32,
                                     7.3923174227787607f32,
                                     7.4008794362821844f32,
                                     7.4093909361377026f32,
                                     7.4178525148858991f32,
                                     7.4262647547020979f32,
                                     7.4346282276367255f32,
                                     7.4429434958487288f32,
                                     7.4512111118323299f32,
                                     7.4594316186372973f32,
                                     7.4676055500829976f32,
                                     7.4757334309663976f32,
                                     7.4838157772642564f32,
                                     7.4918530963296748f32,
                                     7.4998458870832057f32,
                                     7.5077946401986964f32,
                                     7.5156998382840436f32,
                                     7.5235619560570131f32,
                                     7.5313814605163119f32,
                                     7.5391588111080319f32,
                                     7.5468944598876373f32,
                                     7.5545888516776376f32,
                                     7.5622424242210728f32,
                                     7.5698556083309478f32,
                                     7.5774288280357487f32,
                                     7.5849625007211561f32,
                                     7.5924570372680806f32,
                                     7.5999128421871278f32,
                                     7.6073303137496113f32,
                                     7.6147098441152075f32,
                                     7.6220518194563764f32,
                                     7.6293566200796095f32,
                                     7.6366246205436488f32,
                                     7.6438561897747244f32,
                                     7.6510516911789290f32,
                                     7.6582114827517955f32,
                                     7.6653359171851765f32,
                                     7.6724253419714952f32,
                                     7.6794800995054464f32,
                                     7.6865005271832185f32,
                                     7.6934869574993252f32,
                                     7.7004397181410926f32,
                                     7.7073591320808825f32,
                                     7.7142455176661224f32,
                                     7.7210991887071856f32,
                                     7.7279204545631996f32,
                                     7.7347096202258392f32,
                                     7.7414669864011465f32,
                                     7.7481928495894596f32,
                                     7.7548875021634691f32,
                                     7.7615512324444795f32,
                                     7.7681843247769260f32,
                                     7.7747870596011737f32,
                                     7.7813597135246608f32,
                                     7.7879025593914317f32,
                                     7.7944158663501062f32,
                                     7.8008998999203047f32,
                                     7.8073549220576037f32,
                                     7.8137811912170374f32,
                                     7.8201789624151887f32,
                                     7.8265484872909159f32,
                                     7.8328900141647422f32,
                                     7.8392037880969445f32,
                                     7.8454900509443757f32,
                                     7.8517490414160571f32,
                                     7.8579809951275719f32,
                                     7.8641861446542798f32,
                                     7.8703647195834048f32,
                                     7.8765169465650002f32,
                                     7.8826430493618425f32,
                                     7.8887432488982601f32,
                                     7.8948177633079446f32,
                                     7.9008668079807496f32,
                                     7.9068905956085187f32,
                                     7.9128893362299619f32,
                                     7.9188632372745955f32,
                                     7.9248125036057813f32,
                                     7.9307373375628867f32,
                                     7.9366379390025719f32,
                                     7.9425145053392399f32,
                                     7.9483672315846778f32,
                                     7.9541963103868758f32,
                                     7.9600019320680806f32,
                                     7.9657842846620870f32,
                                     7.9715435539507720f32,
                                     7.9772799234999168f32,
                                     7.9829935746943104f32,
                                     7.9886846867721664f32,
                                     7.9943534368588578f32];

static mut kInsBase: [u32; 24] = [0u32, 1u32, 2u32, 3u32, 4u32, 5u32, 6u32, 8u32, 10u32, 14u32,
                                  18u32, 26u32, 34u32, 50u32, 66u32, 98u32, 130u32, 194u32,
                                  322u32, 578u32, 1090u32, 2114u32, 6210u32, 22594u32];

static mut kInsExtra: [u32; 24] = [0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 1u32, 1u32, 2u32, 2u32,
                                   3u32, 3u32, 4u32, 4u32, 5u32, 5u32, 6u32, 7u32, 8u32, 9u32,
                                   10u32, 12u32, 14u32, 24u32];

static mut kCopyBase: [u32; 24] = [2u32, 3u32, 4u32, 5u32, 6u32, 7u32, 8u32, 9u32, 10u32, 12u32,
                                   14u32, 18u32, 22u32, 30u32, 38u32, 54u32, 70u32, 102u32,
                                   134u32, 198u32, 326u32, 582u32, 1094u32, 2118u32];

static mut kCopyExtra: [u32; 24] = [0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 1u32, 1u32,
                                    2u32, 2u32, 3u32, 3u32, 4u32, 4u32, 5u32, 5u32, 6u32, 7u32,
                                    8u32, 9u32, 10u32, 24u32];

static kBrotliMinWindowBits: i32 = 10i32;

static kBrotliMaxWindowBits: i32 = 24i32;

static mut kUTF8ContextLookup: [u8; 512] = [0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            4i32 as (u8),
                                            4i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            4i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            8i32 as (u8),
                                            12i32 as (u8),
                                            16i32 as (u8),
                                            12i32 as (u8),
                                            12i32 as (u8),
                                            20i32 as (u8),
                                            12i32 as (u8),
                                            16i32 as (u8),
                                            24i32 as (u8),
                                            28i32 as (u8),
                                            12i32 as (u8),
                                            12i32 as (u8),
                                            32i32 as (u8),
                                            12i32 as (u8),
                                            36i32 as (u8),
                                            12i32 as (u8),
                                            44i32 as (u8),
                                            44i32 as (u8),
                                            44i32 as (u8),
                                            44i32 as (u8),
                                            44i32 as (u8),
                                            44i32 as (u8),
                                            44i32 as (u8),
                                            44i32 as (u8),
                                            44i32 as (u8),
                                            44i32 as (u8),
                                            32i32 as (u8),
                                            32i32 as (u8),
                                            24i32 as (u8),
                                            40i32 as (u8),
                                            28i32 as (u8),
                                            12i32 as (u8),
                                            12i32 as (u8),
                                            48i32 as (u8),
                                            52i32 as (u8),
                                            52i32 as (u8),
                                            52i32 as (u8),
                                            48i32 as (u8),
                                            52i32 as (u8),
                                            52i32 as (u8),
                                            52i32 as (u8),
                                            48i32 as (u8),
                                            52i32 as (u8),
                                            52i32 as (u8),
                                            52i32 as (u8),
                                            52i32 as (u8),
                                            52i32 as (u8),
                                            48i32 as (u8),
                                            52i32 as (u8),
                                            52i32 as (u8),
                                            52i32 as (u8),
                                            52i32 as (u8),
                                            52i32 as (u8),
                                            48i32 as (u8),
                                            52i32 as (u8),
                                            52i32 as (u8),
                                            52i32 as (u8),
                                            52i32 as (u8),
                                            52i32 as (u8),
                                            24i32 as (u8),
                                            12i32 as (u8),
                                            28i32 as (u8),
                                            12i32 as (u8),
                                            12i32 as (u8),
                                            12i32 as (u8),
                                            56i32 as (u8),
                                            60i32 as (u8),
                                            60i32 as (u8),
                                            60i32 as (u8),
                                            56i32 as (u8),
                                            60i32 as (u8),
                                            60i32 as (u8),
                                            60i32 as (u8),
                                            56i32 as (u8),
                                            60i32 as (u8),
                                            60i32 as (u8),
                                            60i32 as (u8),
                                            60i32 as (u8),
                                            60i32 as (u8),
                                            56i32 as (u8),
                                            60i32 as (u8),
                                            60i32 as (u8),
                                            60i32 as (u8),
                                            60i32 as (u8),
                                            60i32 as (u8),
                                            56i32 as (u8),
                                            60i32 as (u8),
                                            60i32 as (u8),
                                            60i32 as (u8),
                                            60i32 as (u8),
                                            60i32 as (u8),
                                            24i32 as (u8),
                                            12i32 as (u8),
                                            28i32 as (u8),
                                            12i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            2i32 as (u8),
                                            3i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            3i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            1i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            0i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8),
                                            2i32 as (u8)];

static mut kSigned3BitContextLookup: [u8; 256] = [0i32 as (u8),
                                                  1i32 as (u8),
                                                  1i32 as (u8),
                                                  1i32 as (u8),
                                                  1i32 as (u8),
                                                  1i32 as (u8),
                                                  1i32 as (u8),
                                                  1i32 as (u8),
                                                  1i32 as (u8),
                                                  1i32 as (u8),
                                                  1i32 as (u8),
                                                  1i32 as (u8),
                                                  1i32 as (u8),
                                                  1i32 as (u8),
                                                  1i32 as (u8),
                                                  1i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  2i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  3i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  4i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  5i32 as (u8),
                                                  6i32 as (u8),
                                                  6i32 as (u8),
                                                  6i32 as (u8),
                                                  6i32 as (u8),
                                                  6i32 as (u8),
                                                  6i32 as (u8),
                                                  6i32 as (u8),
                                                  6i32 as (u8),
                                                  6i32 as (u8),
                                                  6i32 as (u8),
                                                  6i32 as (u8),
                                                  6i32 as (u8),
                                                  6i32 as (u8),
                                                  6i32 as (u8),
                                                  6i32 as (u8),
                                                  7i32 as (u8)];



pub struct MemoryManager {
  pub alloc_func: fn(*mut ::std::os::raw::c_void, usize) -> *mut ::std::os::raw::c_void,
  pub free_func: fn(*mut ::std::os::raw::c_void, *mut ::std::os::raw::c_void),
  pub opaque: *mut ::std::os::raw::c_void,
}


#[repr(i32)]
pub enum BrotliEncoderMode {
  BROTLI_MODE_GENERIC = 0i32,
  BROTLI_MODE_TEXT = 1i32,
  BROTLI_MODE_FONT = 2i32,
}



pub struct BrotliHasherParams {
  pub type_: i32,
  pub bucket_bits: i32,
  pub block_bits: i32,
  pub hash_len: i32,
  pub num_last_distances_to_check: i32,
}



pub struct BrotliEncoderParams {
  pub mode: BrotliEncoderMode,
  pub quality: i32,
  pub lgwin: i32,
  pub lgblock: i32,
  pub size_hint: usize,
  pub disable_literal_context_modeling: i32,
  pub hasher: BrotliHasherParams,
}



pub struct Command {
  pub insert_len_: u32,
  pub copy_len_: u32,
  pub dist_extra_: u32,
  pub cmd_prefix_: u16,
  pub dist_prefix_: u16,
}


#[repr(i32)]
pub enum ContextType {
  CONTEXT_LSB6 = 0i32,
  CONTEXT_MSB6 = 1i32,
  CONTEXT_UTF8 = 2i32,
  CONTEXT_SIGNED = 3i32,
}



pub struct BlockSplit {
  pub num_types: usize,
  pub num_blocks: usize,
  pub types: *mut u8,
  pub lengths: *mut u32,
  pub types_alloc_size: usize,
  pub lengths_alloc_size: usize,
}



pub struct HistogramLiteral {
  pub data_: [u32; 256],
  pub total_count_: usize,
  pub bit_cost_: f64,
}



pub struct HistogramCommand {
  pub data_: [u32; 704],
  pub total_count_: usize,
  pub bit_cost_: f64,
}



pub struct HistogramDistance {
  pub data_: [u32; 520],
  pub total_count_: usize,
  pub bit_cost_: f64,
}



pub struct MetaBlockSplit {
  pub literal_split: BlockSplit,
  pub command_split: BlockSplit,
  pub distance_split: BlockSplit,
  pub literal_context_map: *mut u32,
  pub literal_context_map_size: usize,
  pub distance_context_map: *mut u32,
  pub distance_context_map_size: usize,
  pub literal_histograms: *mut HistogramLiteral,
  pub literal_histograms_size: usize,
  pub command_histograms: *mut HistogramCommand,
  pub command_histograms_size: usize,
  pub distance_histograms: *mut HistogramDistance,
  pub distance_histograms_size: usize,
}

fn HistogramClearLiteral(mut xself: &mut HistogramLiteral) {
  memset((*xself).data_.as_mut_ptr(),
         0i32,
         ::std::mem::size_of::<[u32; 256]>());
  (*xself).total_count_ = 0usize;
  (*xself).bit_cost_ = 3.402e+38f64;
}

fn ClearHistogramsLiteral(mut array: &mut [HistogramLiteral], mut length: usize) {
  let mut i: usize;
  i = 0usize;
  while i < length {
    HistogramClearLiteral(array[(i as (usize))..]);
    i = i.wrapping_add(1 as (usize));
  }
}

fn HistogramClearDistance(mut xself: &mut HistogramDistance) {
  memset((*xself).data_.as_mut_ptr(),
         0i32,
         ::std::mem::size_of::<[u32; 520]>());
  (*xself).total_count_ = 0usize;
  (*xself).bit_cost_ = 3.402e+38f64;
}

fn ClearHistogramsDistance(mut array: &mut [HistogramDistance], mut length: usize) {
  let mut i: usize;
  i = 0usize;
  while i < length {
    HistogramClearDistance(array[(i as (usize))..]);
    i = i.wrapping_add(1 as (usize));
  }
}

fn HistogramClearCommand(mut xself: &mut HistogramCommand) {
  memset((*xself).data_.as_mut_ptr(),
         0i32,
         ::std::mem::size_of::<[u32; 704]>());
  (*xself).total_count_ = 0usize;
  (*xself).bit_cost_ = 3.402e+38f64;
}

fn ClearHistogramsCommand(mut array: &mut [HistogramCommand], mut length: usize) {
  let mut i: usize;
  i = 0usize;
  while i < length {
    HistogramClearCommand(array[(i as (usize))..]);
    i = i.wrapping_add(1 as (usize));
  }
}


pub fn BrotliBuildMetaBlock(mut m: &mut [MemoryManager],
                            mut ringbuffer: &[u8],
                            pos: usize,
                            mask: usize,
                            mut params: &[BrotliEncoderParams],
                            mut prev_byte: u8,
                            mut prev_byte2: u8,
                            mut cmds: &[Command],
                            mut num_commands: usize,
                            mut literal_context_mode: ContextType,
                            mut mb: &mut [MetaBlockSplit]) {
  static kMaxNumberOfHistograms: usize = 256usize;
  let mut distance_histograms: *mut HistogramDistance;
  let mut literal_histograms: *mut HistogramLiteral;
  let mut literal_context_modes: *mut ContextType = 0i32;
  let mut literal_histograms_size: usize;
  let mut distance_histograms_size: usize;
  let mut i: usize;
  let mut literal_context_multiplier: usize = 1usize;
  BrotliSplitBlock(m,
                   cmds,
                   num_commands,
                   ringbuffer,
                   pos,
                   mask,
                   params,
                   &mut (*mb).literal_split,
                   &mut (*mb).command_split,
                   &mut (*mb).distance_split);
  if !(0i32 == 0) {
    return;
  }
  if (*params).disable_literal_context_modeling == 0 {
    literal_context_multiplier = (1i32 << 6i32) as (usize);
    literal_context_modes = if (*mb).literal_split.num_types != 0 {
      BrotliAllocate(m,
                     (*mb)
                       .literal_split
                       .num_types
                       .wrapping_mul(::std::mem::size_of::<ContextType>()))
    } else {
      0i32
    };
    if !(0i32 == 0) {
      return;
    }
    i = 0usize;
    while i < (*mb).literal_split.num_types {
      {
        literal_context_modes[(i as (usize))] = literal_context_mode;
      }
      i = i.wrapping_add(1 as (usize));
    }
  }
  literal_histograms_size = (*mb).literal_split.num_types.wrapping_mul(literal_context_multiplier);
  literal_histograms = if literal_histograms_size != 0 {
    BrotliAllocate(m,
                   literal_histograms_size.wrapping_mul(::std::mem::size_of::<HistogramLiteral>()))
  } else {
    0i32
  };
  if !(0i32 == 0) {
    return;
  }
  ClearHistogramsLiteral(literal_histograms, literal_histograms_size);
  distance_histograms_size = (*mb).distance_split.num_types << 2i32;
  distance_histograms = if distance_histograms_size != 0 {
    BrotliAllocate(
                                  m,
                                  distance_histograms_size.wrapping_mul(
                                      ::std::mem::size_of::<HistogramDistance>()
                                  )
                              )
  } else {
    0i32
  };
  if !(0i32 == 0) {
    return;
  }
  ClearHistogramsDistance(distance_histograms, distance_histograms_size);
  0i32;
  (*mb).command_histograms_size = (*mb).command_split.num_types;
  (*mb).command_histograms = if (*mb).command_histograms_size != 0 {
    BrotliAllocate(m,
                   (*mb)
                     .command_histograms_size
                     .wrapping_mul(::std::mem::size_of::<HistogramCommand>()))
  } else {
    0i32
  };
  if !(0i32 == 0) {
    return;
  }
  ClearHistogramsCommand((*mb).command_histograms, (*mb).command_histograms_size);
  BrotliBuildHistogramsWithContext(cmds,
                                   num_commands,
                                   &mut (*mb).literal_split,
                                   &mut (*mb).command_split,
                                   &mut (*mb).distance_split,
                                   ringbuffer,
                                   pos,
                                   mask,
                                   prev_byte,
                                   prev_byte2,
                                   literal_context_modes,
                                   literal_histograms,
                                   (*mb).command_histograms,
                                   distance_histograms);
  {
    BrotliFree(m, literal_context_modes);
    literal_context_modes = 0i32;
  }
  0i32;
  (*mb).literal_context_map_size = (*mb).literal_split.num_types << 6i32;
  (*mb).literal_context_map = if (*mb).literal_context_map_size != 0 {
    BrotliAllocate(m,
                   (*mb).literal_context_map_size.wrapping_mul(::std::mem::size_of::<u32>()))
  } else {
    0i32
  };
  if !(0i32 == 0) {
    return;
  }
  0i32;
  (*mb).literal_histograms_size = (*mb).literal_context_map_size;
  (*mb).literal_histograms = if (*mb).literal_histograms_size != 0 {
    BrotliAllocate(m,
                   (*mb)
                     .literal_histograms_size
                     .wrapping_mul(::std::mem::size_of::<HistogramLiteral>()))
  } else {
    0i32
  };
  if !(0i32 == 0) {
    return;
  }
  BrotliClusterHistogramsLiteral(m,
                                 literal_histograms,
                                 literal_histograms_size,
                                 kMaxNumberOfHistograms,
                                 (*mb).literal_histograms,
                                 &mut (*mb).literal_histograms_size,
                                 (*mb).literal_context_map);
  if !(0i32 == 0) {
    return;
  }
  {
    BrotliFree(m, literal_histograms);
    literal_histograms = 0i32;
  }
  if (*params).disable_literal_context_modeling != 0 {
    i = (*mb).literal_split.num_types;
    while i != 0usize {
      let mut j: usize = 0usize;
      i = i.wrapping_sub(1 as (usize));
      while j < (1i32 << 6i32) as (usize) {
        {
          *(*mb).literal_context_map[((i << 6i32).wrapping_add(j) as (usize))..] =
            *(*mb).literal_context_map[(i as (usize))..];
        }
        j = j.wrapping_add(1 as (usize));
      }
    }
  }
  0i32;
  (*mb).distance_context_map_size = (*mb).distance_split.num_types << 2i32;
  (*mb).distance_context_map = if (*mb).distance_context_map_size != 0 {
    BrotliAllocate(m,
                   (*mb).distance_context_map_size.wrapping_mul(::std::mem::size_of::<u32>()))
  } else {
    0i32
  };
  if !(0i32 == 0) {
    return;
  }
  0i32;
  (*mb).distance_histograms_size = (*mb).distance_context_map_size;
  (*mb).distance_histograms = if (*mb).distance_histograms_size != 0 {
    BrotliAllocate(m,
                   (*mb)
                     .distance_histograms_size
                     .wrapping_mul(::std::mem::size_of::<HistogramDistance>()))
  } else {
    0i32
  };
  if !(0i32 == 0) {
    return;
  }
  BrotliClusterHistogramsDistance(m,
                                  distance_histograms,
                                  (*mb).distance_context_map_size,
                                  kMaxNumberOfHistograms,
                                  (*mb).distance_histograms,
                                  &mut (*mb).distance_histograms_size,
                                  (*mb).distance_context_map);
  if !(0i32 == 0) {
    return;
  }
  {
    BrotliFree(m, distance_histograms);
    distance_histograms = 0i32;
  }
}



pub struct BlockSplitterLiteral {
  pub alphabet_size_: usize,
  pub min_block_size_: usize,
  pub split_threshold_: f64,
  pub num_blocks_: usize,
  pub split_: *mut BlockSplit,
  pub histograms_: *mut HistogramLiteral,
  pub histograms_size_: *mut usize,
  pub target_block_size_: usize,
  pub block_size_: usize,
  pub curr_histogram_ix_: usize,
  pub last_histogram_ix_: [usize; 2],
  pub last_entropy_: [f64; 2],
  pub merge_last_count_: usize,
}



pub struct ContextBlockSplitter {
  pub alphabet_size_: usize,
  pub num_contexts_: usize,
  pub max_block_types_: usize,
  pub min_block_size_: usize,
  pub split_threshold_: f64,
  pub num_blocks_: usize,
  pub split_: *mut BlockSplit,
  pub histograms_: *mut HistogramLiteral,
  pub histograms_size_: *mut usize,
  pub target_block_size_: usize,
  pub block_size_: usize,
  pub curr_histogram_ix_: usize,
  pub last_histogram_ix_: [usize; 2],
  pub last_entropy_: [f64; 6],
  pub merge_last_count_: usize,
}



pub struct LitBlocks {
  pub plain: BlockSplitterLiteral,
  pub ctx: ContextBlockSplitter,
}



pub struct BlockSplitterCommand {
  pub alphabet_size_: usize,
  pub min_block_size_: usize,
  pub split_threshold_: f64,
  pub num_blocks_: usize,
  pub split_: *mut BlockSplit,
  pub histograms_: *mut HistogramCommand,
  pub histograms_size_: *mut usize,
  pub target_block_size_: usize,
  pub block_size_: usize,
  pub curr_histogram_ix_: usize,
  pub last_histogram_ix_: [usize; 2],
  pub last_entropy_: [f64; 2],
  pub merge_last_count_: usize,
}



pub struct BlockSplitterDistance {
  pub alphabet_size_: usize,
  pub min_block_size_: usize,
  pub split_threshold_: f64,
  pub num_blocks_: usize,
  pub split_: *mut BlockSplit,
  pub histograms_: *mut HistogramDistance,
  pub histograms_size_: *mut usize,
  pub target_block_size_: usize,
  pub block_size_: usize,
  pub curr_histogram_ix_: usize,
  pub last_histogram_ix_: [usize; 2],
  pub last_entropy_: [f64; 2],
  pub merge_last_count_: usize,
}

fn brotli_min_size_t(mut a: usize, mut b: usize) -> usize {
  if a < b { a } else { b }
}

fn InitBlockSplitterLiteral(mut m: &mut [MemoryManager],
                            mut xself: &mut BlockSplitterLiteral,
                            mut alphabet_size: usize,
                            mut min_block_size: usize,
                            mut split_threshold: f64,
                            mut num_symbols: usize,
                            mut split: &mut [BlockSplit],
                            mut histograms: &mut [*mut HistogramLiteral],
                            mut histograms_size: &mut [usize]) {
  let mut max_num_blocks: usize = num_symbols.wrapping_div(min_block_size).wrapping_add(1usize);
  let mut max_num_types: usize = brotli_min_size_t(max_num_blocks, (256i32 + 1i32) as (usize));
  (*xself).alphabet_size_ = alphabet_size;
  (*xself).min_block_size_ = min_block_size;
  (*xself).split_threshold_ = split_threshold;
  (*xself).num_blocks_ = 0usize;
  (*xself).split_ = split;
  (*xself).histograms_size_ = histograms_size;
  (*xself).target_block_size_ = min_block_size;
  (*xself).block_size_ = 0usize;
  (*xself).curr_histogram_ix_ = 0usize;
  (*xself).merge_last_count_ = 0usize;
  {
    if (*split).types_alloc_size < max_num_blocks {
      let mut _new_size: usize = if (*split).types_alloc_size == 0usize {
        max_num_blocks
      } else {
        (*split).types_alloc_size
      };
      let mut new_array: *mut u8;
      while _new_size < max_num_blocks {
        _new_size = _new_size.wrapping_mul(2usize);
      }
      new_array = if _new_size != 0 {
        BrotliAllocate(m, _new_size.wrapping_mul(::std::mem::size_of::<u8>()))
      } else {
        0i32
      };
      if !!(0i32 == 0) && ((*split).types_alloc_size != 0usize) {
        memcpy(new_array,
               (*split).types,
               (*split).types_alloc_size.wrapping_mul(::std::mem::size_of::<u8>()));
      }
      {
        BrotliFree(m, (*split).types);
        (*split).types = 0i32;
      }
      (*split).types = new_array;
      (*split).types_alloc_size = _new_size;
    }
  }
  {
    if (*split).lengths_alloc_size < max_num_blocks {
      let mut _new_size: usize = if (*split).lengths_alloc_size == 0usize {
        max_num_blocks
      } else {
        (*split).lengths_alloc_size
      };
      let mut new_array: *mut u32;
      while _new_size < max_num_blocks {
        _new_size = _new_size.wrapping_mul(2usize);
      }
      new_array = if _new_size != 0 {
        BrotliAllocate(m, _new_size.wrapping_mul(::std::mem::size_of::<u32>()))
      } else {
        0i32
      };
      if !!(0i32 == 0) && ((*split).lengths_alloc_size != 0usize) {
        memcpy(new_array,
               (*split).lengths,
               (*split).lengths_alloc_size.wrapping_mul(::std::mem::size_of::<u32>()));
      }
      {
        BrotliFree(m, (*split).lengths);
        (*split).lengths = 0i32;
      }
      (*split).lengths = new_array;
      (*split).lengths_alloc_size = _new_size;
    }
  }
  if !(0i32 == 0) {
    return;
  }
  (*(*xself).split_).num_blocks = max_num_blocks;
  0i32;
  *histograms_size = max_num_types;
  *histograms = if *histograms_size != 0 {
    BrotliAllocate(m,
                   (*histograms_size).wrapping_mul(::std::mem::size_of::<HistogramLiteral>()))
  } else {
    0i32
  };
  (*xself).histograms_ = *histograms;
  if !(0i32 == 0) {
    return;
  }
  HistogramClearLiteral(&mut *(*xself).histograms_[(0usize)..]);
  (*xself).last_histogram_ix_[0usize] = {
    let _rhs = 0i32;
    let _lhs = &mut (*xself).last_histogram_ix_[1usize];
    *_lhs = _rhs as (usize);
    *_lhs
  };
}

fn InitContextBlockSplitter(mut m: &mut [MemoryManager],
                            mut xself: &mut ContextBlockSplitter,
                            mut alphabet_size: usize,
                            mut num_contexts: usize,
                            mut min_block_size: usize,
                            mut split_threshold: f64,
                            mut num_symbols: usize,
                            mut split: &mut [BlockSplit],
                            mut histograms: &mut [*mut HistogramLiteral],
                            mut histograms_size: &mut [usize]) {
  let mut max_num_blocks: usize = num_symbols.wrapping_div(min_block_size).wrapping_add(1usize);
  let mut max_num_types: usize;
  0i32;
  (*xself).alphabet_size_ = alphabet_size;
  (*xself).num_contexts_ = num_contexts;
  (*xself).max_block_types_ = (256usize).wrapping_div(num_contexts);
  (*xself).min_block_size_ = min_block_size;
  (*xself).split_threshold_ = split_threshold;
  (*xself).num_blocks_ = 0usize;
  (*xself).split_ = split;
  (*xself).histograms_size_ = histograms_size;
  (*xself).target_block_size_ = min_block_size;
  (*xself).block_size_ = 0usize;
  (*xself).curr_histogram_ix_ = 0usize;
  (*xself).merge_last_count_ = 0usize;
  max_num_types = brotli_min_size_t(max_num_blocks,
                                    (*xself).max_block_types_.wrapping_add(1usize));
  {
    if (*split).types_alloc_size < max_num_blocks {
      let mut _new_size: usize = if (*split).types_alloc_size == 0usize {
        max_num_blocks
      } else {
        (*split).types_alloc_size
      };
      let mut new_array: *mut u8;
      while _new_size < max_num_blocks {
        _new_size = _new_size.wrapping_mul(2usize);
      }
      new_array = if _new_size != 0 {
        BrotliAllocate(m, _new_size.wrapping_mul(::std::mem::size_of::<u8>()))
      } else {
        0i32
      };
      if !!(0i32 == 0) && ((*split).types_alloc_size != 0usize) {
        memcpy(new_array,
               (*split).types,
               (*split).types_alloc_size.wrapping_mul(::std::mem::size_of::<u8>()));
      }
      {
        BrotliFree(m, (*split).types);
        (*split).types = 0i32;
      }
      (*split).types = new_array;
      (*split).types_alloc_size = _new_size;
    }
  }
  {
    if (*split).lengths_alloc_size < max_num_blocks {
      let mut _new_size: usize = if (*split).lengths_alloc_size == 0usize {
        max_num_blocks
      } else {
        (*split).lengths_alloc_size
      };
      let mut new_array: *mut u32;
      while _new_size < max_num_blocks {
        _new_size = _new_size.wrapping_mul(2usize);
      }
      new_array = if _new_size != 0 {
        BrotliAllocate(m, _new_size.wrapping_mul(::std::mem::size_of::<u32>()))
      } else {
        0i32
      };
      if !!(0i32 == 0) && ((*split).lengths_alloc_size != 0usize) {
        memcpy(new_array,
               (*split).lengths,
               (*split).lengths_alloc_size.wrapping_mul(::std::mem::size_of::<u32>()));
      }
      {
        BrotliFree(m, (*split).lengths);
        (*split).lengths = 0i32;
      }
      (*split).lengths = new_array;
      (*split).lengths_alloc_size = _new_size;
    }
  }
  if !(0i32 == 0) {
    return;
  }
  (*split).num_blocks = max_num_blocks;
  if !(0i32 == 0) {
    return;
  }
  0i32;
  *histograms_size = max_num_types.wrapping_mul(num_contexts);
  *histograms = if *histograms_size != 0 {
    BrotliAllocate(m,
                   (*histograms_size).wrapping_mul(::std::mem::size_of::<HistogramLiteral>()))
  } else {
    0i32
  };
  (*xself).histograms_ = *histograms;
  if !(0i32 == 0) {
    return;
  }
  ClearHistogramsLiteral(&mut *(*xself).histograms_[(0usize)..], num_contexts);
  (*xself).last_histogram_ix_[0usize] = {
    let _rhs = 0i32;
    let _lhs = &mut (*xself).last_histogram_ix_[1usize];
    *_lhs = _rhs as (usize);
    *_lhs
  };
}

fn InitBlockSplitterCommand(mut m: &mut [MemoryManager],
                            mut xself: &mut BlockSplitterCommand,
                            mut alphabet_size: usize,
                            mut min_block_size: usize,
                            mut split_threshold: f64,
                            mut num_symbols: usize,
                            mut split: &mut [BlockSplit],
                            mut histograms: &mut [*mut HistogramCommand],
                            mut histograms_size: &mut [usize]) {
  let mut max_num_blocks: usize = num_symbols.wrapping_div(min_block_size).wrapping_add(1usize);
  let mut max_num_types: usize = brotli_min_size_t(max_num_blocks, (256i32 + 1i32) as (usize));
  (*xself).alphabet_size_ = alphabet_size;
  (*xself).min_block_size_ = min_block_size;
  (*xself).split_threshold_ = split_threshold;
  (*xself).num_blocks_ = 0usize;
  (*xself).split_ = split;
  (*xself).histograms_size_ = histograms_size;
  (*xself).target_block_size_ = min_block_size;
  (*xself).block_size_ = 0usize;
  (*xself).curr_histogram_ix_ = 0usize;
  (*xself).merge_last_count_ = 0usize;
  {
    if (*split).types_alloc_size < max_num_blocks {
      let mut _new_size: usize = if (*split).types_alloc_size == 0usize {
        max_num_blocks
      } else {
        (*split).types_alloc_size
      };
      let mut new_array: *mut u8;
      while _new_size < max_num_blocks {
        _new_size = _new_size.wrapping_mul(2usize);
      }
      new_array = if _new_size != 0 {
        BrotliAllocate(m, _new_size.wrapping_mul(::std::mem::size_of::<u8>()))
      } else {
        0i32
      };
      if !!(0i32 == 0) && ((*split).types_alloc_size != 0usize) {
        memcpy(new_array,
               (*split).types,
               (*split).types_alloc_size.wrapping_mul(::std::mem::size_of::<u8>()));
      }
      {
        BrotliFree(m, (*split).types);
        (*split).types = 0i32;
      }
      (*split).types = new_array;
      (*split).types_alloc_size = _new_size;
    }
  }
  {
    if (*split).lengths_alloc_size < max_num_blocks {
      let mut _new_size: usize = if (*split).lengths_alloc_size == 0usize {
        max_num_blocks
      } else {
        (*split).lengths_alloc_size
      };
      let mut new_array: *mut u32;
      while _new_size < max_num_blocks {
        _new_size = _new_size.wrapping_mul(2usize);
      }
      new_array = if _new_size != 0 {
        BrotliAllocate(m, _new_size.wrapping_mul(::std::mem::size_of::<u32>()))
      } else {
        0i32
      };
      if !!(0i32 == 0) && ((*split).lengths_alloc_size != 0usize) {
        memcpy(new_array,
               (*split).lengths,
               (*split).lengths_alloc_size.wrapping_mul(::std::mem::size_of::<u32>()));
      }
      {
        BrotliFree(m, (*split).lengths);
        (*split).lengths = 0i32;
      }
      (*split).lengths = new_array;
      (*split).lengths_alloc_size = _new_size;
    }
  }
  if !(0i32 == 0) {
    return;
  }
  (*(*xself).split_).num_blocks = max_num_blocks;
  0i32;
  *histograms_size = max_num_types;
  *histograms = if *histograms_size != 0 {
    BrotliAllocate(m,
                   (*histograms_size).wrapping_mul(::std::mem::size_of::<HistogramCommand>()))
  } else {
    0i32
  };
  (*xself).histograms_ = *histograms;
  if !(0i32 == 0) {
    return;
  }
  HistogramClearCommand(&mut *(*xself).histograms_[(0usize)..]);
  (*xself).last_histogram_ix_[0usize] = {
    let _rhs = 0i32;
    let _lhs = &mut (*xself).last_histogram_ix_[1usize];
    *_lhs = _rhs as (usize);
    *_lhs
  };
}

fn InitBlockSplitterDistance(mut m: &mut [MemoryManager],
                             mut xself: &mut BlockSplitterDistance,
                             mut alphabet_size: usize,
                             mut min_block_size: usize,
                             mut split_threshold: f64,
                             mut num_symbols: usize,
                             mut split: &mut [BlockSplit],
                             mut histograms: &mut [*mut HistogramDistance],
                             mut histograms_size: &mut [usize]) {
  let mut max_num_blocks: usize = num_symbols.wrapping_div(min_block_size).wrapping_add(1usize);
  let mut max_num_types: usize = brotli_min_size_t(max_num_blocks, (256i32 + 1i32) as (usize));
  (*xself).alphabet_size_ = alphabet_size;
  (*xself).min_block_size_ = min_block_size;
  (*xself).split_threshold_ = split_threshold;
  (*xself).num_blocks_ = 0usize;
  (*xself).split_ = split;
  (*xself).histograms_size_ = histograms_size;
  (*xself).target_block_size_ = min_block_size;
  (*xself).block_size_ = 0usize;
  (*xself).curr_histogram_ix_ = 0usize;
  (*xself).merge_last_count_ = 0usize;
  {
    if (*split).types_alloc_size < max_num_blocks {
      let mut _new_size: usize = if (*split).types_alloc_size == 0usize {
        max_num_blocks
      } else {
        (*split).types_alloc_size
      };
      let mut new_array: *mut u8;
      while _new_size < max_num_blocks {
        _new_size = _new_size.wrapping_mul(2usize);
      }
      new_array = if _new_size != 0 {
        BrotliAllocate(m, _new_size.wrapping_mul(::std::mem::size_of::<u8>()))
      } else {
        0i32
      };
      if !!(0i32 == 0) && ((*split).types_alloc_size != 0usize) {
        memcpy(new_array,
               (*split).types,
               (*split).types_alloc_size.wrapping_mul(::std::mem::size_of::<u8>()));
      }
      {
        BrotliFree(m, (*split).types);
        (*split).types = 0i32;
      }
      (*split).types = new_array;
      (*split).types_alloc_size = _new_size;
    }
  }
  {
    if (*split).lengths_alloc_size < max_num_blocks {
      let mut _new_size: usize = if (*split).lengths_alloc_size == 0usize {
        max_num_blocks
      } else {
        (*split).lengths_alloc_size
      };
      let mut new_array: *mut u32;
      while _new_size < max_num_blocks {
        _new_size = _new_size.wrapping_mul(2usize);
      }
      new_array = if _new_size != 0 {
        BrotliAllocate(m, _new_size.wrapping_mul(::std::mem::size_of::<u32>()))
      } else {
        0i32
      };
      if !!(0i32 == 0) && ((*split).lengths_alloc_size != 0usize) {
        memcpy(new_array,
               (*split).lengths,
               (*split).lengths_alloc_size.wrapping_mul(::std::mem::size_of::<u32>()));
      }
      {
        BrotliFree(m, (*split).lengths);
        (*split).lengths = 0i32;
      }
      (*split).lengths = new_array;
      (*split).lengths_alloc_size = _new_size;
    }
  }
  if !(0i32 == 0) {
    return;
  }
  (*(*xself).split_).num_blocks = max_num_blocks;
  0i32;
  *histograms_size = max_num_types;
  *histograms = if *histograms_size != 0 {
    BrotliAllocate(m,
                   (*histograms_size).wrapping_mul(::std::mem::size_of::<HistogramDistance>()))
  } else {
    0i32
  };
  (*xself).histograms_ = *histograms;
  if !(0i32 == 0) {
    return;
  }
  HistogramClearDistance(&mut *(*xself).histograms_[(0usize)..]);
  (*xself).last_histogram_ix_[0usize] = {
    let _rhs = 0i32;
    let _lhs = &mut (*xself).last_histogram_ix_[1usize];
    *_lhs = _rhs as (usize);
    *_lhs
  };
}

fn HistogramAddCommand(mut xself: &mut HistogramCommand, mut val: usize) {
  {
    let _rhs = 1;
    let _lhs = &mut (*xself).data_[val];
    *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
  }
  (*xself).total_count_ = (*xself).total_count_.wrapping_add(1 as (usize));
}

fn brotli_max_size_t(mut a: usize, mut b: usize) -> usize {
  if a > b { a } else { b }
}

fn FastLog2(mut v: usize) -> f64 {
  if v < ::std::mem::size_of::<[f32; 256]>().wrapping_div(::std::mem::size_of::<f32>()) {
    return kLog2Table[v] as (f64);
  }
  log2(v as (f64))
}

fn ShannonEntropy(mut population: &[u32], mut size: usize, mut total: &mut usize) -> f64 {
  let mut sum: usize = 0usize;
  let mut retval: f64 = 0i32 as (f64);
  let mut population_end: *const u32 = population[(size as (usize))..];
  let mut p: usize;
  let mut odd_number_of_elements_left: i32 = 0i32;
  if size & 1usize != 0 {
    odd_number_of_elements_left = 1i32;
  }
  while population < population_end {
    if odd_number_of_elements_left == 0 {
      p = *{
             let _old = population;
             population = population[(1 as (usize))..];
             _old
           } as (usize);
      sum = sum.wrapping_add(p);
      retval = retval - p as (f64) * FastLog2(p);
    }
    odd_number_of_elements_left = 0i32;
    p = *{
           let _old = population;
           population = population[(1 as (usize))..];
           _old
         } as (usize);
    sum = sum.wrapping_add(p);
    retval = retval - p as (f64) * FastLog2(p);
  }
  if sum != 0 {
    retval = retval + sum as (f64) * FastLog2(sum);
  }
  *total = sum;
  retval
}

fn BitsEntropy(mut population: &[u32], mut size: usize) -> f64 {
  let mut sum: usize;
  let mut retval: f64 = ShannonEntropy(population, size, &mut sum);
  if retval < sum as (f64) {
    retval = sum as (f64);
  }
  retval
}

fn HistogramAddHistogramCommand(mut xself: &mut HistogramCommand, mut v: &[HistogramCommand]) {
  let mut i: usize;
  (*xself).total_count_ = (*xself).total_count_.wrapping_add((*v).total_count_);
  i = 0usize;
  while i < 704usize {
    {
      let _rhs = (*v).data_[i];
      let _lhs = &mut (*xself).data_[i];
      *_lhs = (*_lhs).wrapping_add(_rhs);
    }
    i = i.wrapping_add(1 as (usize));
  }
}

fn BlockSplitterFinishBlockCommand(mut xself: &mut BlockSplitterCommand, mut is_final: i32) {
  let mut split: *mut BlockSplit = (*xself).split_;
  let mut last_entropy: *mut f64 = (*xself).last_entropy_.as_mut_ptr();
  let mut histograms: *mut HistogramCommand = (*xself).histograms_;
  (*xself).block_size_ = brotli_max_size_t((*xself).block_size_, (*xself).min_block_size_);
  if (*xself).num_blocks_ == 0usize {
    *(*split).lengths[(0usize)..] = (*xself).block_size_ as (u32);
    *(*split).types[(0usize)..] = 0i32 as (u8);
    last_entropy[(0usize)] = BitsEntropy((histograms[(0usize)]).data_.as_mut_ptr(),
                                         (*xself).alphabet_size_);
    last_entropy[(1usize)] = last_entropy[(0usize)];
    (*xself).num_blocks_ = (*xself).num_blocks_.wrapping_add(1 as (usize));
    (*split).num_types = (*split).num_types.wrapping_add(1 as (usize));
    (*xself).curr_histogram_ix_ = (*xself).curr_histogram_ix_.wrapping_add(1 as (usize));
    if (*xself).curr_histogram_ix_ < *(*xself).histograms_size_ {
      HistogramClearCommand(&mut histograms[((*xself).curr_histogram_ix_ as (usize))]);
    }
    (*xself).block_size_ = 0usize;
  } else if (*xself).block_size_ > 0usize {
    let mut entropy: f64 =
      BitsEntropy((histograms[((*xself).curr_histogram_ix_ as (usize))]).data_.as_mut_ptr(),
                  (*xself).alphabet_size_);
    let mut combined_histo: [HistogramCommand; 2];
    let mut combined_entropy: [f64; 2];
    let mut diff: [f64; 2];
    let mut j: usize;
    j = 0usize;
    while j < 2usize {
      {
        let mut last_histogram_ix: usize = (*xself).last_histogram_ix_[j];
        combined_histo[j] = histograms[((*xself).curr_histogram_ix_ as (usize))];
        HistogramAddHistogramCommand(&mut combined_histo[j],
                                     &mut histograms[(last_histogram_ix as (usize))]);
        combined_entropy[j] = BitsEntropy(&mut combined_histo[j].data_[0usize],
                                          (*xself).alphabet_size_);
        diff[j] = combined_entropy[j] - entropy - last_entropy[(j as (usize))];
      }
      j = j.wrapping_add(1 as (usize));
    }
    if (*split).num_types < 256usize && (diff[0usize] > (*xself).split_threshold_) &&
       (diff[1usize] > (*xself).split_threshold_) {
      *(*split).lengths[((*xself).num_blocks_ as (usize))..] = (*xself).block_size_ as (u32);
      *(*split).types[((*xself).num_blocks_ as (usize))..] = (*split).num_types as (u8);
      (*xself).last_histogram_ix_[1usize] = (*xself).last_histogram_ix_[0usize];
      (*xself).last_histogram_ix_[0usize] = (*split).num_types as (u8) as (usize);
      last_entropy[(1usize)] = last_entropy[(0usize)];
      last_entropy[(0usize)] = entropy;
      (*xself).num_blocks_ = (*xself).num_blocks_.wrapping_add(1 as (usize));
      (*split).num_types = (*split).num_types.wrapping_add(1 as (usize));
      (*xself).curr_histogram_ix_ = (*xself).curr_histogram_ix_.wrapping_add(1 as (usize));
      if (*xself).curr_histogram_ix_ < *(*xself).histograms_size_ {
        HistogramClearCommand(&mut histograms[((*xself).curr_histogram_ix_ as (usize))]);
      }
      (*xself).block_size_ = 0usize;
      (*xself).merge_last_count_ = 0usize;
      (*xself).target_block_size_ = (*xself).min_block_size_;
    } else if diff[1usize] < diff[0usize] - 20.0f64 {
      *(*split).lengths[((*xself).num_blocks_ as (usize))..] = (*xself).block_size_ as (u32);
      *(*split).types[((*xself).num_blocks_ as (usize))..] =
        *(*split).types[((*xself).num_blocks_.wrapping_sub(2usize) as (usize))..];
      {
        let mut __brotli_swap_tmp: usize = (*xself).last_histogram_ix_[0usize];
        (*xself).last_histogram_ix_[0usize] = (*xself).last_histogram_ix_[1usize];
        (*xself).last_histogram_ix_[1usize] = __brotli_swap_tmp;
      }
      histograms[((*xself).last_histogram_ix_[0usize] as (usize))] = combined_histo[1usize];
      last_entropy[(1usize)] = last_entropy[(0usize)];
      last_entropy[(0usize)] = combined_entropy[1usize];
      (*xself).num_blocks_ = (*xself).num_blocks_.wrapping_add(1 as (usize));
      (*xself).block_size_ = 0usize;
      HistogramClearCommand(&mut histograms[((*xself).curr_histogram_ix_ as (usize))]);
      (*xself).merge_last_count_ = 0usize;
      (*xself).target_block_size_ = (*xself).min_block_size_;
    } else {
      {
        let _rhs = (*xself).block_size_ as (u32);
        let _lhs = &mut *(*split).lengths[((*xself).num_blocks_.wrapping_sub(1usize) as (usize))..];
        *_lhs = (*_lhs).wrapping_add(_rhs);
      }
      histograms[((*xself).last_histogram_ix_[0usize] as (usize))] = combined_histo[0usize];
      last_entropy[(0usize)] = combined_entropy[0usize];
      if (*split).num_types == 1usize {
        last_entropy[(1usize)] = last_entropy[(0usize)];
      }
      (*xself).block_size_ = 0usize;
      HistogramClearCommand(&mut histograms[((*xself).curr_histogram_ix_ as (usize))]);
      if {
           (*xself).merge_last_count_ = (*xself).merge_last_count_.wrapping_add(1 as (usize));
           (*xself).merge_last_count_
         } > 1usize {
        (*xself).target_block_size_ =
          (*xself).target_block_size_.wrapping_add((*xself).min_block_size_);
      }
    }
  }
  if is_final != 0 {
    *(*xself).histograms_size_ = (*split).num_types;
    (*split).num_blocks = (*xself).num_blocks_;
  }
}

fn BlockSplitterAddSymbolCommand(mut xself: &mut BlockSplitterCommand, mut symbol: usize) {
  HistogramAddCommand(&mut *(*xself).histograms_[((*xself).curr_histogram_ix_ as (usize))..],
                      symbol);
  (*xself).block_size_ = (*xself).block_size_.wrapping_add(1 as (usize));
  if (*xself).block_size_ == (*xself).target_block_size_ {
    BlockSplitterFinishBlockCommand(xself, 0i32);
  }
}

fn HistogramAddLiteral(mut xself: &mut HistogramLiteral, mut val: usize) {
  {
    let _rhs = 1;
    let _lhs = &mut (*xself).data_[val];
    *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
  }
  (*xself).total_count_ = (*xself).total_count_.wrapping_add(1 as (usize));
}

fn HistogramAddHistogramLiteral(mut xself: &mut HistogramLiteral, mut v: &[HistogramLiteral]) {
  let mut i: usize;
  (*xself).total_count_ = (*xself).total_count_.wrapping_add((*v).total_count_);
  i = 0usize;
  while i < 256usize {
    {
      let _rhs = (*v).data_[i];
      let _lhs = &mut (*xself).data_[i];
      *_lhs = (*_lhs).wrapping_add(_rhs);
    }
    i = i.wrapping_add(1 as (usize));
  }
}

fn BlockSplitterFinishBlockLiteral(mut xself: &mut BlockSplitterLiteral, mut is_final: i32) {
  let mut split: *mut BlockSplit = (*xself).split_;
  let mut last_entropy: *mut f64 = (*xself).last_entropy_.as_mut_ptr();
  let mut histograms: *mut HistogramLiteral = (*xself).histograms_;
  (*xself).block_size_ = brotli_max_size_t((*xself).block_size_, (*xself).min_block_size_);
  if (*xself).num_blocks_ == 0usize {
    *(*split).lengths[(0usize)..] = (*xself).block_size_ as (u32);
    *(*split).types[(0usize)..] = 0i32 as (u8);
    last_entropy[(0usize)] = BitsEntropy((histograms[(0usize)]).data_.as_mut_ptr(),
                                         (*xself).alphabet_size_);
    last_entropy[(1usize)] = last_entropy[(0usize)];
    (*xself).num_blocks_ = (*xself).num_blocks_.wrapping_add(1 as (usize));
    (*split).num_types = (*split).num_types.wrapping_add(1 as (usize));
    (*xself).curr_histogram_ix_ = (*xself).curr_histogram_ix_.wrapping_add(1 as (usize));
    if (*xself).curr_histogram_ix_ < *(*xself).histograms_size_ {
      HistogramClearLiteral(&mut histograms[((*xself).curr_histogram_ix_ as (usize))]);
    }
    (*xself).block_size_ = 0usize;
  } else if (*xself).block_size_ > 0usize {
    let mut entropy: f64 =
      BitsEntropy((histograms[((*xself).curr_histogram_ix_ as (usize))]).data_.as_mut_ptr(),
                  (*xself).alphabet_size_);
    let mut combined_histo: [HistogramLiteral; 2];
    let mut combined_entropy: [f64; 2];
    let mut diff: [f64; 2];
    let mut j: usize;
    j = 0usize;
    while j < 2usize {
      {
        let mut last_histogram_ix: usize = (*xself).last_histogram_ix_[j];
        combined_histo[j] = histograms[((*xself).curr_histogram_ix_ as (usize))];
        HistogramAddHistogramLiteral(&mut combined_histo[j],
                                     &mut histograms[(last_histogram_ix as (usize))]);
        combined_entropy[j] = BitsEntropy(&mut combined_histo[j].data_[0usize],
                                          (*xself).alphabet_size_);
        diff[j] = combined_entropy[j] - entropy - last_entropy[(j as (usize))];
      }
      j = j.wrapping_add(1 as (usize));
    }
    if (*split).num_types < 256usize && (diff[0usize] > (*xself).split_threshold_) &&
       (diff[1usize] > (*xself).split_threshold_) {
      *(*split).lengths[((*xself).num_blocks_ as (usize))..] = (*xself).block_size_ as (u32);
      *(*split).types[((*xself).num_blocks_ as (usize))..] = (*split).num_types as (u8);
      (*xself).last_histogram_ix_[1usize] = (*xself).last_histogram_ix_[0usize];
      (*xself).last_histogram_ix_[0usize] = (*split).num_types as (u8) as (usize);
      last_entropy[(1usize)] = last_entropy[(0usize)];
      last_entropy[(0usize)] = entropy;
      (*xself).num_blocks_ = (*xself).num_blocks_.wrapping_add(1 as (usize));
      (*split).num_types = (*split).num_types.wrapping_add(1 as (usize));
      (*xself).curr_histogram_ix_ = (*xself).curr_histogram_ix_.wrapping_add(1 as (usize));
      if (*xself).curr_histogram_ix_ < *(*xself).histograms_size_ {
        HistogramClearLiteral(&mut histograms[((*xself).curr_histogram_ix_ as (usize))]);
      }
      (*xself).block_size_ = 0usize;
      (*xself).merge_last_count_ = 0usize;
      (*xself).target_block_size_ = (*xself).min_block_size_;
    } else if diff[1usize] < diff[0usize] - 20.0f64 {
      *(*split).lengths[((*xself).num_blocks_ as (usize))..] = (*xself).block_size_ as (u32);
      *(*split).types[((*xself).num_blocks_ as (usize))..] =
        *(*split).types[((*xself).num_blocks_.wrapping_sub(2usize) as (usize))..];
      {
        let mut __brotli_swap_tmp: usize = (*xself).last_histogram_ix_[0usize];
        (*xself).last_histogram_ix_[0usize] = (*xself).last_histogram_ix_[1usize];
        (*xself).last_histogram_ix_[1usize] = __brotli_swap_tmp;
      }
      histograms[((*xself).last_histogram_ix_[0usize] as (usize))] = combined_histo[1usize];
      last_entropy[(1usize)] = last_entropy[(0usize)];
      last_entropy[(0usize)] = combined_entropy[1usize];
      (*xself).num_blocks_ = (*xself).num_blocks_.wrapping_add(1 as (usize));
      (*xself).block_size_ = 0usize;
      HistogramClearLiteral(&mut histograms[((*xself).curr_histogram_ix_ as (usize))]);
      (*xself).merge_last_count_ = 0usize;
      (*xself).target_block_size_ = (*xself).min_block_size_;
    } else {
      {
        let _rhs = (*xself).block_size_ as (u32);
        let _lhs = &mut *(*split).lengths[((*xself).num_blocks_.wrapping_sub(1usize) as (usize))..];
        *_lhs = (*_lhs).wrapping_add(_rhs);
      }
      histograms[((*xself).last_histogram_ix_[0usize] as (usize))] = combined_histo[0usize];
      last_entropy[(0usize)] = combined_entropy[0usize];
      if (*split).num_types == 1usize {
        last_entropy[(1usize)] = last_entropy[(0usize)];
      }
      (*xself).block_size_ = 0usize;
      HistogramClearLiteral(&mut histograms[((*xself).curr_histogram_ix_ as (usize))]);
      if {
           (*xself).merge_last_count_ = (*xself).merge_last_count_.wrapping_add(1 as (usize));
           (*xself).merge_last_count_
         } > 1usize {
        (*xself).target_block_size_ =
          (*xself).target_block_size_.wrapping_add((*xself).min_block_size_);
      }
    }
  }
  if is_final != 0 {
    *(*xself).histograms_size_ = (*split).num_types;
    (*split).num_blocks = (*xself).num_blocks_;
  }
}

fn BlockSplitterAddSymbolLiteral(mut xself: &mut BlockSplitterLiteral, mut symbol: usize) {
  HistogramAddLiteral(&mut *(*xself).histograms_[((*xself).curr_histogram_ix_ as (usize))..],
                      symbol);
  (*xself).block_size_ = (*xself).block_size_.wrapping_add(1 as (usize));
  if (*xself).block_size_ == (*xself).target_block_size_ {
    BlockSplitterFinishBlockLiteral(xself, 0i32);
  }
}

fn Context(mut p1: u8, mut p2: u8, mut mode: ContextType) -> u8 {
  if mode as (i32) == ContextType::CONTEXT_LSB6 as (i32) {
    return (p1 as (i32) & 0x3fi32) as (u8);
  }
  if mode as (i32) == ContextType::CONTEXT_MSB6 as (i32) {
    return (p1 as (i32) >> 2i32) as (u8);
  }
  if mode as (i32) == ContextType::CONTEXT_UTF8 as (i32) {
    return (kUTF8ContextLookup[p1 as (usize)] as (i32) |
            kUTF8ContextLookup[(p2 as (i32) + 256i32) as (usize)] as (i32)) as (u8);
  }
  if mode as (i32) == ContextType::CONTEXT_SIGNED as (i32) {
    return ((kSigned3BitContextLookup[p1 as (usize)] as (i32) << 3i32) +
            kSigned3BitContextLookup[p2 as (usize)] as (i32)) as (u8);
  }
  0i32 as (u8)
}

fn ContextBlockSplitterFinishBlock(mut xself: &mut ContextBlockSplitter, mut is_final: i32) {
  let mut split: *mut BlockSplit = (*xself).split_;
  let num_contexts: usize = (*xself).num_contexts_;
  let mut last_entropy: *mut f64 = (*xself).last_entropy_.as_mut_ptr();
  let mut histograms: *mut HistogramLiteral = (*xself).histograms_;
  if (*xself).block_size_ < (*xself).min_block_size_ {
    (*xself).block_size_ = (*xself).min_block_size_;
  }
  if (*xself).num_blocks_ == 0usize {
    let mut i: usize;
    *(*split).lengths[(0usize)..] = (*xself).block_size_ as (u32);
    *(*split).types[(0usize)..] = 0i32 as (u8);
    i = 0usize;
    while i < num_contexts {
      {
        last_entropy[(i as (usize))] = BitsEntropy((histograms[(i as (usize))]).data_.as_mut_ptr(),
                                                   (*xself).alphabet_size_);
        last_entropy[(num_contexts.wrapping_add(i) as (usize))] = last_entropy[(i as (usize))];
      }
      i = i.wrapping_add(1 as (usize));
    }
    (*xself).num_blocks_ = (*xself).num_blocks_.wrapping_add(1 as (usize));
    (*split).num_types = (*split).num_types.wrapping_add(1 as (usize));
    (*xself).curr_histogram_ix_ = (*xself).curr_histogram_ix_.wrapping_add(num_contexts);
    if (*xself).curr_histogram_ix_ < *(*xself).histograms_size_ {
      ClearHistogramsLiteral(&mut *(*xself).histograms_[((*xself).curr_histogram_ix_ as
                                    (usize))..],
                             (*xself).num_contexts_);
    }
    (*xself).block_size_ = 0usize;
  } else if (*xself).block_size_ > 0usize {
    let mut entropy: [f64; 3];
    let mut combined_histo: [HistogramLiteral; 6];
    let mut combined_entropy: [f64; 6];
    let mut diff: [f64; 2] = [0.0f64, 0.0f64];
    let mut i: usize;
    i = 0usize;
    while i < num_contexts {
      {
        let mut curr_histo_ix: usize = (*xself).curr_histogram_ix_.wrapping_add(i);
        let mut j: usize;
        entropy[i] = BitsEntropy((histograms[(curr_histo_ix as (usize))]).data_.as_mut_ptr(),
                                 (*xself).alphabet_size_);
        j = 0usize;
        while j < 2usize {
          {
            let mut jx: usize = j.wrapping_mul(num_contexts).wrapping_add(i);
            let mut last_histogram_ix: usize = (*xself).last_histogram_ix_[j].wrapping_add(i);
            combined_histo[jx] = histograms[(curr_histo_ix as (usize))];
            HistogramAddHistogramLiteral(&mut combined_histo[jx],
                                         &mut histograms[(last_histogram_ix as (usize))]);
            combined_entropy[jx] = BitsEntropy(&mut combined_histo[jx].data_[0usize],
                                               (*xself).alphabet_size_);
            {
              let _rhs = combined_entropy[jx] - entropy[i] - last_entropy[(jx as (usize))];
              let _lhs = &mut diff[j];
              *_lhs = *_lhs + _rhs;
            }
          }
          j = j.wrapping_add(1 as (usize));
        }
      }
      i = i.wrapping_add(1 as (usize));
    }
    if (*split).num_types < (*xself).max_block_types_ &&
       (diff[0usize] > (*xself).split_threshold_) &&
       (diff[1usize] > (*xself).split_threshold_) {
      *(*split).lengths[((*xself).num_blocks_ as (usize))..] = (*xself).block_size_ as (u32);
      *(*split).types[((*xself).num_blocks_ as (usize))..] = (*split).num_types as (u8);
      (*xself).last_histogram_ix_[1usize] = (*xself).last_histogram_ix_[0usize];
      (*xself).last_histogram_ix_[0usize] = (*split).num_types.wrapping_mul(num_contexts);
      i = 0usize;
      while i < num_contexts {
        {
          last_entropy[(num_contexts.wrapping_add(i) as (usize))] = last_entropy[(i as (usize))];
          last_entropy[(i as (usize))] = entropy[i];
        }
        i = i.wrapping_add(1 as (usize));
      }
      (*xself).num_blocks_ = (*xself).num_blocks_.wrapping_add(1 as (usize));
      (*split).num_types = (*split).num_types.wrapping_add(1 as (usize));
      (*xself).curr_histogram_ix_ = (*xself).curr_histogram_ix_.wrapping_add(num_contexts);
      if (*xself).curr_histogram_ix_ < *(*xself).histograms_size_ {
        ClearHistogramsLiteral(&mut *(*xself).histograms_[((*xself).curr_histogram_ix_ as
                                      (usize))..],
                               (*xself).num_contexts_);
      }
      (*xself).block_size_ = 0usize;
      (*xself).merge_last_count_ = 0usize;
      (*xself).target_block_size_ = (*xself).min_block_size_;
    } else if diff[1usize] < diff[0usize] - 20.0f64 {
      *(*split).lengths[((*xself).num_blocks_ as (usize))..] = (*xself).block_size_ as (u32);
      *(*split).types[((*xself).num_blocks_ as (usize))..] =
        *(*split).types[((*xself).num_blocks_.wrapping_sub(2usize) as (usize))..];
      {
        let mut __brotli_swap_tmp: usize = (*xself).last_histogram_ix_[0usize];
        (*xself).last_histogram_ix_[0usize] = (*xself).last_histogram_ix_[1usize];
        (*xself).last_histogram_ix_[1usize] = __brotli_swap_tmp;
      }
      i = 0usize;
      while i < num_contexts {
        {
          histograms[((*xself).last_histogram_ix_[0usize].wrapping_add(i) as (usize))] =
            combined_histo[num_contexts.wrapping_add(i)];
          last_entropy[(num_contexts.wrapping_add(i) as (usize))] = last_entropy[(i as (usize))];
          last_entropy[(i as (usize))] = combined_entropy[num_contexts.wrapping_add(i)];
          HistogramClearLiteral(&mut histograms[((*xself).curr_histogram_ix_.wrapping_add(i) as
                                      (usize))]);
        }
        i = i.wrapping_add(1 as (usize));
      }
      (*xself).num_blocks_ = (*xself).num_blocks_.wrapping_add(1 as (usize));
      (*xself).block_size_ = 0usize;
      (*xself).merge_last_count_ = 0usize;
      (*xself).target_block_size_ = (*xself).min_block_size_;
    } else {
      {
        let _rhs = (*xself).block_size_ as (u32);
        let _lhs = &mut *(*split).lengths[((*xself).num_blocks_.wrapping_sub(1usize) as (usize))..];
        *_lhs = (*_lhs).wrapping_add(_rhs);
      }
      i = 0usize;
      while i < num_contexts {
        {
          histograms[((*xself).last_histogram_ix_[0usize].wrapping_add(i) as (usize))] =
            combined_histo[i];
          last_entropy[(i as (usize))] = combined_entropy[i];
          if (*split).num_types == 1usize {
            last_entropy[(num_contexts.wrapping_add(i) as (usize))] = last_entropy[(i as (usize))];
          }
          HistogramClearLiteral(&mut histograms[((*xself).curr_histogram_ix_.wrapping_add(i) as
                                      (usize))]);
        }
        i = i.wrapping_add(1 as (usize));
      }
      (*xself).block_size_ = 0usize;
      if {
           (*xself).merge_last_count_ = (*xself).merge_last_count_.wrapping_add(1 as (usize));
           (*xself).merge_last_count_
         } > 1usize {
        (*xself).target_block_size_ =
          (*xself).target_block_size_.wrapping_add((*xself).min_block_size_);
      }
    }
  }
  if is_final != 0 {
    *(*xself).histograms_size_ = (*split).num_types.wrapping_mul(num_contexts);
    (*split).num_blocks = (*xself).num_blocks_;
  }
}

fn ContextBlockSplitterAddSymbol(mut xself: &mut ContextBlockSplitter,
                                 mut symbol: usize,
                                 mut context: usize) {
  HistogramAddLiteral(&mut *(*xself).histograms_[((*xself).curr_histogram_ix_.wrapping_add(context) as
                             (usize))..],
                      symbol);
  (*xself).block_size_ = (*xself).block_size_.wrapping_add(1 as (usize));
  if (*xself).block_size_ == (*xself).target_block_size_ {
    ContextBlockSplitterFinishBlock(xself, 0i32);
  }
}

fn CommandCopyLen(mut xself: &Command) -> u32 {
  (*xself).copy_len_ & 0xffffffu32
}

fn HistogramAddDistance(mut xself: &mut HistogramDistance, mut val: usize) {
  {
    let _rhs = 1;
    let _lhs = &mut (*xself).data_[val];
    *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
  }
  (*xself).total_count_ = (*xself).total_count_.wrapping_add(1 as (usize));
}

fn HistogramAddHistogramDistance(mut xself: &mut HistogramDistance, mut v: &[HistogramDistance]) {
  let mut i: usize;
  (*xself).total_count_ = (*xself).total_count_.wrapping_add((*v).total_count_);
  i = 0usize;
  while i < 520usize {
    {
      let _rhs = (*v).data_[i];
      let _lhs = &mut (*xself).data_[i];
      *_lhs = (*_lhs).wrapping_add(_rhs);
    }
    i = i.wrapping_add(1 as (usize));
  }
}

fn BlockSplitterFinishBlockDistance(mut xself: &mut BlockSplitterDistance, mut is_final: i32) {
  let mut split: *mut BlockSplit = (*xself).split_;
  let mut last_entropy: *mut f64 = (*xself).last_entropy_.as_mut_ptr();
  let mut histograms: *mut HistogramDistance = (*xself).histograms_;
  (*xself).block_size_ = brotli_max_size_t((*xself).block_size_, (*xself).min_block_size_);
  if (*xself).num_blocks_ == 0usize {
    *(*split).lengths[(0usize)..] = (*xself).block_size_ as (u32);
    *(*split).types[(0usize)..] = 0i32 as (u8);
    last_entropy[(0usize)] = BitsEntropy((histograms[(0usize)]).data_.as_mut_ptr(),
                                         (*xself).alphabet_size_);
    last_entropy[(1usize)] = last_entropy[(0usize)];
    (*xself).num_blocks_ = (*xself).num_blocks_.wrapping_add(1 as (usize));
    (*split).num_types = (*split).num_types.wrapping_add(1 as (usize));
    (*xself).curr_histogram_ix_ = (*xself).curr_histogram_ix_.wrapping_add(1 as (usize));
    if (*xself).curr_histogram_ix_ < *(*xself).histograms_size_ {
      HistogramClearDistance(&mut histograms[((*xself).curr_histogram_ix_ as (usize))]);
    }
    (*xself).block_size_ = 0usize;
  } else if (*xself).block_size_ > 0usize {
    let mut entropy: f64 =
      BitsEntropy((histograms[((*xself).curr_histogram_ix_ as (usize))]).data_.as_mut_ptr(),
                  (*xself).alphabet_size_);
    let mut combined_histo: [HistogramDistance; 2];
    let mut combined_entropy: [f64; 2];
    let mut diff: [f64; 2];
    let mut j: usize;
    j = 0usize;
    while j < 2usize {
      {
        let mut last_histogram_ix: usize = (*xself).last_histogram_ix_[j];
        combined_histo[j] = histograms[((*xself).curr_histogram_ix_ as (usize))];
        HistogramAddHistogramDistance(&mut combined_histo[j],
                                      &mut histograms[(last_histogram_ix as (usize))]);
        combined_entropy[j] = BitsEntropy(&mut combined_histo[j].data_[0usize],
                                          (*xself).alphabet_size_);
        diff[j] = combined_entropy[j] - entropy - last_entropy[(j as (usize))];
      }
      j = j.wrapping_add(1 as (usize));
    }
    if (*split).num_types < 256usize && (diff[0usize] > (*xself).split_threshold_) &&
       (diff[1usize] > (*xself).split_threshold_) {
      *(*split).lengths[((*xself).num_blocks_ as (usize))..] = (*xself).block_size_ as (u32);
      *(*split).types[((*xself).num_blocks_ as (usize))..] = (*split).num_types as (u8);
      (*xself).last_histogram_ix_[1usize] = (*xself).last_histogram_ix_[0usize];
      (*xself).last_histogram_ix_[0usize] = (*split).num_types as (u8) as (usize);
      last_entropy[(1usize)] = last_entropy[(0usize)];
      last_entropy[(0usize)] = entropy;
      (*xself).num_blocks_ = (*xself).num_blocks_.wrapping_add(1 as (usize));
      (*split).num_types = (*split).num_types.wrapping_add(1 as (usize));
      (*xself).curr_histogram_ix_ = (*xself).curr_histogram_ix_.wrapping_add(1 as (usize));
      if (*xself).curr_histogram_ix_ < *(*xself).histograms_size_ {
        HistogramClearDistance(&mut histograms[((*xself).curr_histogram_ix_ as (usize))]);
      }
      (*xself).block_size_ = 0usize;
      (*xself).merge_last_count_ = 0usize;
      (*xself).target_block_size_ = (*xself).min_block_size_;
    } else if diff[1usize] < diff[0usize] - 20.0f64 {
      *(*split).lengths[((*xself).num_blocks_ as (usize))..] = (*xself).block_size_ as (u32);
      *(*split).types[((*xself).num_blocks_ as (usize))..] =
        *(*split).types[((*xself).num_blocks_.wrapping_sub(2usize) as (usize))..];
      {
        let mut __brotli_swap_tmp: usize = (*xself).last_histogram_ix_[0usize];
        (*xself).last_histogram_ix_[0usize] = (*xself).last_histogram_ix_[1usize];
        (*xself).last_histogram_ix_[1usize] = __brotli_swap_tmp;
      }
      histograms[((*xself).last_histogram_ix_[0usize] as (usize))] = combined_histo[1usize];
      last_entropy[(1usize)] = last_entropy[(0usize)];
      last_entropy[(0usize)] = combined_entropy[1usize];
      (*xself).num_blocks_ = (*xself).num_blocks_.wrapping_add(1 as (usize));
      (*xself).block_size_ = 0usize;
      HistogramClearDistance(&mut histograms[((*xself).curr_histogram_ix_ as (usize))]);
      (*xself).merge_last_count_ = 0usize;
      (*xself).target_block_size_ = (*xself).min_block_size_;
    } else {
      {
        let _rhs = (*xself).block_size_ as (u32);
        let _lhs = &mut *(*split).lengths[((*xself).num_blocks_.wrapping_sub(1usize) as (usize))..];
        *_lhs = (*_lhs).wrapping_add(_rhs);
      }
      histograms[((*xself).last_histogram_ix_[0usize] as (usize))] = combined_histo[0usize];
      last_entropy[(0usize)] = combined_entropy[0usize];
      if (*split).num_types == 1usize {
        last_entropy[(1usize)] = last_entropy[(0usize)];
      }
      (*xself).block_size_ = 0usize;
      HistogramClearDistance(&mut histograms[((*xself).curr_histogram_ix_ as (usize))]);
      if {
           (*xself).merge_last_count_ = (*xself).merge_last_count_.wrapping_add(1 as (usize));
           (*xself).merge_last_count_
         } > 1usize {
        (*xself).target_block_size_ =
          (*xself).target_block_size_.wrapping_add((*xself).min_block_size_);
      }
    }
  }
  if is_final != 0 {
    *(*xself).histograms_size_ = (*split).num_types;
    (*split).num_blocks = (*xself).num_blocks_;
  }
}

fn BlockSplitterAddSymbolDistance(mut xself: &mut BlockSplitterDistance, mut symbol: usize) {
  HistogramAddDistance(&mut *(*xself).histograms_[((*xself).curr_histogram_ix_ as (usize))..],
                       symbol);
  (*xself).block_size_ = (*xself).block_size_.wrapping_add(1 as (usize));
  if (*xself).block_size_ == (*xself).target_block_size_ {
    BlockSplitterFinishBlockDistance(xself, 0i32);
  }
}

fn MapStaticContexts(mut m: &mut [MemoryManager],
                     mut num_contexts: usize,
                     mut static_context_map: &[u32],
                     mut mb: &mut [MetaBlockSplit]) {
  let mut i: usize;
  0i32;
  (*mb).literal_context_map_size = (*mb).literal_split.num_types << 6i32;
  (*mb).literal_context_map = if (*mb).literal_context_map_size != 0 {
    BrotliAllocate(m,
                   (*mb).literal_context_map_size.wrapping_mul(::std::mem::size_of::<u32>()))
  } else {
    0i32
  };
  if !(0i32 == 0) {
    return;
  }
  i = 0usize;
  while i < (*mb).literal_split.num_types {
    {
      let mut offset: u32 = i.wrapping_mul(num_contexts) as (u32);
      let mut j: usize;
      j = 0usize;
      while j < (1u32 << 6i32) as (usize) {
        {
          *(*mb).literal_context_map[((i << 6i32).wrapping_add(j) as (usize))..] =
            offset.wrapping_add(static_context_map[(j as (usize))]);
        }
        j = j.wrapping_add(1 as (usize));
      }
    }
    i = i.wrapping_add(1 as (usize));
  }
}

fn BrotliBuildMetaBlockGreedyInternal(mut m: &mut [MemoryManager],
                                      mut ringbuffer: &[u8],
                                      mut pos: usize,
                                      mut mask: usize,
                                      mut prev_byte: u8,
                                      mut prev_byte2: u8,
                                      mut literal_context_mode: ContextType,
                                      num_contexts: usize,
                                      mut static_context_map: &[u32],
                                      mut commands: &[Command],
                                      mut n_commands: usize,
                                      mut mb: &mut [MetaBlockSplit]) {
  let mut lit_blocks: LitBlocks;
  let mut cmd_blocks: BlockSplitterCommand;
  let mut dist_blocks: BlockSplitterDistance;
  let mut num_literals: usize = 0usize;
  let mut i: usize;
  i = 0usize;
  while i < n_commands {
    {
      num_literals = num_literals.wrapping_add((commands[(i as (usize))]).insert_len_ as (usize));
    }
    i = i.wrapping_add(1 as (usize));
  }
  if num_contexts == 1usize {
    InitBlockSplitterLiteral(m,
                             &mut lit_blocks.plain,
                             256usize,
                             512usize,
                             400.0f64,
                             num_literals,
                             &mut (*mb).literal_split,
                             &mut (*mb).literal_histograms,
                             &mut (*mb).literal_histograms_size);
  } else {
    InitContextBlockSplitter(m,
                             &mut lit_blocks.ctx,
                             256usize,
                             num_contexts,
                             512usize,
                             400.0f64,
                             num_literals,
                             &mut (*mb).literal_split,
                             &mut (*mb).literal_histograms,
                             &mut (*mb).literal_histograms_size);
  }
  if !(0i32 == 0) {
    return;
  }
  InitBlockSplitterCommand(m,
                           &mut cmd_blocks,
                           704usize,
                           1024usize,
                           500.0f64,
                           n_commands,
                           &mut (*mb).command_split,
                           &mut (*mb).command_histograms,
                           &mut (*mb).command_histograms_size);
  if !(0i32 == 0) {
    return;
  }
  InitBlockSplitterDistance(m,
                            &mut dist_blocks,
                            64usize,
                            512usize,
                            100.0f64,
                            n_commands,
                            &mut (*mb).distance_split,
                            &mut (*mb).distance_histograms,
                            &mut (*mb).distance_histograms_size);
  if !(0i32 == 0) {
    return;
  }
  i = 0usize;
  while i < n_commands {
    {
      let cmd: Command = commands[(i as (usize))];
      let mut j: usize;
      BlockSplitterAddSymbolCommand(&mut cmd_blocks, cmd.cmd_prefix_ as (usize));
      j = cmd.insert_len_ as (usize);
      while j != 0usize {
        {
          let mut literal: u8 = ringbuffer[((pos & mask) as (usize))];
          if num_contexts == 1usize {
            BlockSplitterAddSymbolLiteral(&mut lit_blocks.plain, literal as (usize));
          } else {
            let mut context: usize = Context(prev_byte, prev_byte2, literal_context_mode) as
                                     (usize);
            ContextBlockSplitterAddSymbol(&mut lit_blocks.ctx,
                                          literal as (usize),
                                          static_context_map[(context as (usize))] as (usize));
          }
          prev_byte2 = prev_byte;
          prev_byte = literal;
          pos = pos.wrapping_add(1 as (usize));
        }
        j = j.wrapping_sub(1 as (usize));
      }
      pos = pos.wrapping_add(CommandCopyLen(&cmd) as (usize));
      if CommandCopyLen(&cmd) != 0 {
        prev_byte2 = ringbuffer[((pos.wrapping_sub(2usize) & mask) as (usize))];
        prev_byte = ringbuffer[((pos.wrapping_sub(1usize) & mask) as (usize))];
        if cmd.cmd_prefix_ as (i32) >= 128i32 {
          BlockSplitterAddSymbolDistance(&mut dist_blocks, cmd.dist_prefix_ as (usize));
        }
      }
    }
    i = i.wrapping_add(1 as (usize));
  }
  if num_contexts == 1usize {
    BlockSplitterFinishBlockLiteral(&mut lit_blocks.plain, 1i32);
  } else {
    ContextBlockSplitterFinishBlock(&mut lit_blocks.ctx, 1i32);
  }
  BlockSplitterFinishBlockCommand(&mut cmd_blocks, 1i32);
  BlockSplitterFinishBlockDistance(&mut dist_blocks, 1i32);
  if num_contexts > 1usize {
    MapStaticContexts(m, num_contexts, static_context_map, mb);
  }
}


pub fn BrotliBuildMetaBlockGreedy(mut m: &mut [MemoryManager],
                                  mut ringbuffer: &[u8],
                                  mut pos: usize,
                                  mut mask: usize,
                                  mut prev_byte: u8,
                                  mut prev_byte2: u8,
                                  mut literal_context_mode: ContextType,
                                  mut num_contexts: usize,
                                  mut static_context_map: &[u32],
                                  mut commands: &[Command],
                                  mut n_commands: usize,
                                  mut mb: &mut [MetaBlockSplit]) {
  if num_contexts == 1usize {
    BrotliBuildMetaBlockGreedyInternal(m,
                                       ringbuffer,
                                       pos,
                                       mask,
                                       prev_byte,
                                       prev_byte2,
                                       literal_context_mode,
                                       1usize,
                                       0i32,
                                       commands,
                                       n_commands,
                                       mb);
  } else {
    BrotliBuildMetaBlockGreedyInternal(m,
                                       ringbuffer,
                                       pos,
                                       mask,
                                       prev_byte,
                                       prev_byte2,
                                       literal_context_mode,
                                       num_contexts,
                                       static_context_map,
                                       commands,
                                       n_commands,
                                       mb);
  }
}


pub fn BrotliOptimizeHistograms(mut num_direct_distance_codes: usize,
                                mut distance_postfix_bits: usize,
                                mut mb: &mut [MetaBlockSplit]) {
  let mut good_for_rle: [u8; 704];
  let mut num_distance_codes: usize;
  let mut i: usize;
  i = 0usize;
  while i < (*mb).literal_histograms_size {
    {
      BrotliOptimizeHuffmanCountsForRle(256usize,
                                        (*(*mb).literal_histograms[(i as (usize))..])
                                          .data_
                                          .as_mut_ptr(),
                                        good_for_rle.as_mut_ptr());
    }
    i = i.wrapping_add(1 as (usize));
  }
  i = 0usize;
  while i < (*mb).command_histograms_size {
    {
      BrotliOptimizeHuffmanCountsForRle(704usize,
                                        (*(*mb).command_histograms[(i as (usize))..])
                                          .data_
                                          .as_mut_ptr(),
                                        good_for_rle.as_mut_ptr());
    }
    i = i.wrapping_add(1 as (usize));
  }
  num_distance_codes =
    (16usize).wrapping_add(num_direct_distance_codes).wrapping_add(((2u32).wrapping_mul(24u32) <<
                                                                    distance_postfix_bits) as
                                                                   (usize));
  i = 0usize;
  while i < (*mb).distance_histograms_size {
    {
      BrotliOptimizeHuffmanCountsForRle(num_distance_codes,
                                        (*(*mb).distance_histograms[(i as (usize))..])
                                          .data_
                                          .as_mut_ptr(),
                                        good_for_rle.as_mut_ptr());
    }
    i = i.wrapping_add(1 as (usize));
  }
}
